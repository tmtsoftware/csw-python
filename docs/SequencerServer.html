<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>csw.SequencerServer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>csw.SequencerServer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json

import aiohttp
from aiohttp import web, WSMessage
from aiohttp.web_request import Request
from aiohttp.web_response import Response
import atexit
import uuid

from aiohttp.web_ws import WebSocketResponse

from csw.CommandResponseManager import CommandResponseManager
from csw.CommandServer import QueryFinal, SubscribeCurrentState
from csw.ComponentHandlers import ComponentHandlers
from csw.ControlCommand import ControlCommand
from csw.Prefix import Prefix
from csw.LocationService import LocationService, ConnectionInfo, ComponentType, ConnectionType, HttpRegistration
import structlog

# Ignore generated functions in API docs
__pdoc__ = {}

log = structlog.get_logger()


class SequencerServer:
    _app = web.Application()
    _crm = CommandResponseManager()

    async def _handlePost(self, request: Request) -&gt; Response:
        obj = await request.json()
        # log.debug(f&#34;received post: {str(obj)}&#34;)
        method = obj[&#39;_type&#39;]
        match method:
            case &#39;LoadSequence&#39;:
                pass
            case &#39;StartSequence&#39;:
                pass
            case &#39;GetSequence&#39;:
                pass
            case &#39;Add&#39;:
                pass
            case &#39;Prepend&#39;:
                pass
            case &#39;Replace&#39;:
                pass
            case &#39;InsertAfter&#39;:
                pass
            case &#39;Delete&#39;:
                pass
            case &#39;Pause&#39;:
                pass
            case &#39;Resume&#39;:
                pass
            case &#39;AddBreakpoint&#39;:
                pass
            case &#39;RemoveBreakpoint&#39;:
                pass
            case &#39;Reset&#39;:
                pass
            case &#39;AbortSequence&#39;:
                pass
            case &#39;Stop&#39;:
                pass
            case &#39;Submit&#39;:
                pass
            case &#39;Query&#39;:
                pass
            case &#39;GoOnline&#39;:
                pass
            case &#39;GoOffline&#39;:
                pass
            case &#39;DiagnosticMode&#39;:
                pass
            case &#39;OperationsMode&#39;:
                pass
            case &#39;GetSequenceComponent&#39;:
                pass
            case &#39;GetSequencerState&#39;:
                pass

        # if method in {&#39;Submit&#39;, &#39;Oneway&#39;, &#39;Validate&#39;}:
        #     command = ControlCommand._fromDict(obj[&#39;controlCommand&#39;])
        #     runId = str(uuid.uuid4())
        #     if method == &#39;Submit&#39;:
        #         commandResponse, task = self.handler.onSubmit(runId, command)
        #         if task is not None:
        #             # noinspection PyTypeChecker
        #             self._crm.addTask(runId, task)
        #             log.debug(&#34;Long running task in progress...&#34;)
        #     elif method == &#39;Oneway&#39;:
        #         commandResponse = self.handler.onOneway(runId, command)
        #     else:
        #         commandResponse = self.handler.validateCommand(runId, command)
        #     responseDict = commandResponse._asDict()
        #     return web.json_response(responseDict)
        # else:
        #     raise Exception(&#34;Invalid command type: &#34; + method)

    async def _handleQueryFinal(self, queryFinal: QueryFinal) -&gt; Response:
        commandResponse = await self._crm.waitForTask(queryFinal.runId, queryFinal.timeoutInSeconds)
        responseDict = commandResponse._asDict()
        return web.json_response(responseDict)

    async def _handleWs(self, request: Request) -&gt; WebSocketResponse:
        ws = web.WebSocketResponse()
        await ws.prepare(request)
        msg: WSMessage
        async for msg in ws:
            if msg.type == aiohttp.WSMsgType.TEXT:
                if msg.data == &#39;close&#39;:
                    log.debug(&#34;Received ws close message&#34;)
                    await ws.close()
                else:
                    obj = json.loads(msg.data)
                    # log.debug(f&#34;received message: {str(obj)}&#34;)
                    method = obj[&#39;_type&#39;]
                    if method == &#34;QueryFinal&#34;:
                        queryFinal = QueryFinal._fromDict(obj)
                        resp = await self._handleQueryFinal(queryFinal)
                        await ws.send_str(resp.text)
                        await ws.close()
                    elif method == &#34;SubscribeCurrentState&#34;:
                        stateNames = SubscribeCurrentState._fromDict(obj).stateNames
                        log.debug(f&#34;Received SubscribeCurrentState: stateNames = {stateNames}&#34;)
                        self.handler._subscribeCurrentState(stateNames, ws)
                    else:
                        log.debug(f&#34;Warning: Received unknown ws message: {str(msg.data)}&#34;)
            elif msg.type == aiohttp.WSMsgType.ERROR:
                log.debug(&#39;Error: ws connection closed with exception %s&#39; % ws.exception())
        log.debug(&#39;websocket connection closed&#39;)
        self.handler._unsubscribeCurrentState(ws)
        return ws

    @staticmethod
    def _registerWithLocationService(prefix: Prefix, port: int):
        log.debug(&#34;Registering with location service using port &#34; + str(port))
        locationService = LocationService()
        connection = ConnectionInfo.make(prefix, ComponentType.Service, ConnectionType.HttpType)
        atexit.register(locationService.unregister, connection)
        # locationService.unregister(connection)
        locationService.register(HttpRegistration(connection, port, &#34;/post-endpoint&#34;))

    def __init__(self, prefix: Prefix, handler: ComponentHandlers, port: int = 8082):
        &#34;&#34;&#34;
        Creates an HTTP server that can receive CSW commands and registers it with the Location Service using the given prefix,
        so that CSW components can locate it and send commands to it.

        Args:
            prefix (str): a CSW Prefix in the format $subsystem.name, where subsystem is one of the upper case TMT
                          subsystem names and name is the name of the command server
            handler (ComponentHandlers): command handler notified when commands are received
            port (int): optional port for HTTP server
        &#34;&#34;&#34;
        self.handler = handler
        self.port = port
        self._app.add_routes([
            web.post(&#39;/post-endpoint&#39;, self._handlePost),
            web.get(&#34;/websocket-endpoint&#34;, self._handleWs)
        ])
        self._registerWithLocationService(prefix, port)

    def start(self):
        &#34;&#34;&#34;
        Starts the command http server in a thread
        &#34;&#34;&#34;
        web.run_app(self._app, port=self.port)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="csw.SequencerServer.SequencerServer"><code class="flex name class">
<span>class <span class="ident">SequencerServer</span></span>
<span>(</span><span>prefix: <a title="csw.Prefix.Prefix" href="Prefix.html#csw.Prefix.Prefix">Prefix</a>, handler: <a title="csw.ComponentHandlers.ComponentHandlers" href="ComponentHandlers.html#csw.ComponentHandlers.ComponentHandlers">ComponentHandlers</a>, port: int = 8082)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an HTTP server that can receive CSW commands and registers it with the Location Service using the given prefix,
so that CSW components can locate it and send commands to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>a CSW Prefix in the format $subsystem.name, where subsystem is one of the upper case TMT
subsystem names and name is the name of the command server</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>ComponentHandlers</code></dt>
<dd>command handler notified when commands are received</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>optional port for HTTP server</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequencerServer:
    _app = web.Application()
    _crm = CommandResponseManager()

    async def _handlePost(self, request: Request) -&gt; Response:
        obj = await request.json()
        # log.debug(f&#34;received post: {str(obj)}&#34;)
        method = obj[&#39;_type&#39;]
        match method:
            case &#39;LoadSequence&#39;:
                pass
            case &#39;StartSequence&#39;:
                pass
            case &#39;GetSequence&#39;:
                pass
            case &#39;Add&#39;:
                pass
            case &#39;Prepend&#39;:
                pass
            case &#39;Replace&#39;:
                pass
            case &#39;InsertAfter&#39;:
                pass
            case &#39;Delete&#39;:
                pass
            case &#39;Pause&#39;:
                pass
            case &#39;Resume&#39;:
                pass
            case &#39;AddBreakpoint&#39;:
                pass
            case &#39;RemoveBreakpoint&#39;:
                pass
            case &#39;Reset&#39;:
                pass
            case &#39;AbortSequence&#39;:
                pass
            case &#39;Stop&#39;:
                pass
            case &#39;Submit&#39;:
                pass
            case &#39;Query&#39;:
                pass
            case &#39;GoOnline&#39;:
                pass
            case &#39;GoOffline&#39;:
                pass
            case &#39;DiagnosticMode&#39;:
                pass
            case &#39;OperationsMode&#39;:
                pass
            case &#39;GetSequenceComponent&#39;:
                pass
            case &#39;GetSequencerState&#39;:
                pass

        # if method in {&#39;Submit&#39;, &#39;Oneway&#39;, &#39;Validate&#39;}:
        #     command = ControlCommand._fromDict(obj[&#39;controlCommand&#39;])
        #     runId = str(uuid.uuid4())
        #     if method == &#39;Submit&#39;:
        #         commandResponse, task = self.handler.onSubmit(runId, command)
        #         if task is not None:
        #             # noinspection PyTypeChecker
        #             self._crm.addTask(runId, task)
        #             log.debug(&#34;Long running task in progress...&#34;)
        #     elif method == &#39;Oneway&#39;:
        #         commandResponse = self.handler.onOneway(runId, command)
        #     else:
        #         commandResponse = self.handler.validateCommand(runId, command)
        #     responseDict = commandResponse._asDict()
        #     return web.json_response(responseDict)
        # else:
        #     raise Exception(&#34;Invalid command type: &#34; + method)

    async def _handleQueryFinal(self, queryFinal: QueryFinal) -&gt; Response:
        commandResponse = await self._crm.waitForTask(queryFinal.runId, queryFinal.timeoutInSeconds)
        responseDict = commandResponse._asDict()
        return web.json_response(responseDict)

    async def _handleWs(self, request: Request) -&gt; WebSocketResponse:
        ws = web.WebSocketResponse()
        await ws.prepare(request)
        msg: WSMessage
        async for msg in ws:
            if msg.type == aiohttp.WSMsgType.TEXT:
                if msg.data == &#39;close&#39;:
                    log.debug(&#34;Received ws close message&#34;)
                    await ws.close()
                else:
                    obj = json.loads(msg.data)
                    # log.debug(f&#34;received message: {str(obj)}&#34;)
                    method = obj[&#39;_type&#39;]
                    if method == &#34;QueryFinal&#34;:
                        queryFinal = QueryFinal._fromDict(obj)
                        resp = await self._handleQueryFinal(queryFinal)
                        await ws.send_str(resp.text)
                        await ws.close()
                    elif method == &#34;SubscribeCurrentState&#34;:
                        stateNames = SubscribeCurrentState._fromDict(obj).stateNames
                        log.debug(f&#34;Received SubscribeCurrentState: stateNames = {stateNames}&#34;)
                        self.handler._subscribeCurrentState(stateNames, ws)
                    else:
                        log.debug(f&#34;Warning: Received unknown ws message: {str(msg.data)}&#34;)
            elif msg.type == aiohttp.WSMsgType.ERROR:
                log.debug(&#39;Error: ws connection closed with exception %s&#39; % ws.exception())
        log.debug(&#39;websocket connection closed&#39;)
        self.handler._unsubscribeCurrentState(ws)
        return ws

    @staticmethod
    def _registerWithLocationService(prefix: Prefix, port: int):
        log.debug(&#34;Registering with location service using port &#34; + str(port))
        locationService = LocationService()
        connection = ConnectionInfo.make(prefix, ComponentType.Service, ConnectionType.HttpType)
        atexit.register(locationService.unregister, connection)
        # locationService.unregister(connection)
        locationService.register(HttpRegistration(connection, port, &#34;/post-endpoint&#34;))

    def __init__(self, prefix: Prefix, handler: ComponentHandlers, port: int = 8082):
        &#34;&#34;&#34;
        Creates an HTTP server that can receive CSW commands and registers it with the Location Service using the given prefix,
        so that CSW components can locate it and send commands to it.

        Args:
            prefix (str): a CSW Prefix in the format $subsystem.name, where subsystem is one of the upper case TMT
                          subsystem names and name is the name of the command server
            handler (ComponentHandlers): command handler notified when commands are received
            port (int): optional port for HTTP server
        &#34;&#34;&#34;
        self.handler = handler
        self.port = port
        self._app.add_routes([
            web.post(&#39;/post-endpoint&#39;, self._handlePost),
            web.get(&#34;/websocket-endpoint&#34;, self._handleWs)
        ])
        self._registerWithLocationService(prefix, port)

    def start(self):
        &#34;&#34;&#34;
        Starts the command http server in a thread
        &#34;&#34;&#34;
        web.run_app(self._app, port=self.port)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="csw.SequencerServer.SequencerServer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the command http server in a thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Starts the command http server in a thread
    &#34;&#34;&#34;
    web.run_app(self._app, port=self.port)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="csw" href="index.html">csw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="csw.SequencerServer.SequencerServer" href="#csw.SequencerServer.SequencerServer">SequencerServer</a></code></h4>
<ul class="">
<li><code><a title="csw.SequencerServer.SequencerServer.start" href="#csw.SequencerServer.SequencerServer.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>