<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>csw.ConfigService API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>csw.ConfigService</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import List
from urllib.parse import urlencode

import re
import requests
from dataclasses_json import dataclass_json
from keycloak import KeycloakOpenID

from csw.LocationService import LocationService, ConnectionInfo, ComponentType, ConnectionType, HttpLocation
from csw.Prefix import Prefix
from csw.Subsystem import Subsystems

@dataclass
class ConfigData:
    &#34;&#34;&#34;
    Represents the contents of a file in the Config Service.
    You can get the content as a string with `s = configData.content.decode(&#39;utf-8&#39;)`.
    Create from a string with `ConfigData(bytes(&#39;hello&#39;, &#39;utf-8&#39;))`.
    &#34;&#34;&#34;
    content: bytes


@dataclass_json
@dataclass
class ConfigId:
    &#34;&#34;&#34;
    Type of an id returned from ConfigManager create or update methods
    &#34;&#34;&#34;
    id: str


@dataclass_json
@dataclass
class ConfigFileInfo:
    &#34;&#34;&#34;
    Contains information about a config file stored in the config service
    &#34;&#34;&#34;
    path: str
    id: str
    author: str
    comment: str


class FileType(Enum):
    &#34;&#34;&#34;
    Represents the type of storage for a configuration file
    &#34;&#34;&#34;
    Normal = 0
    Annex = 1


@dataclass_json
@dataclass
class ConfigMetadata:
    &#34;&#34;&#34;
    Holds metadata information about config server
    &#34;&#34;&#34;
    repoPath: str
    annexPath: str
    annexMinFileSize: str
    maxConfigFileSize: str


@dataclass_json
@dataclass
class ConfigFileRevision:
    &#34;&#34;&#34;
    Holds information about a specific version of a config file
    &#34;&#34;&#34;
    id: str
    author: str
    comment: str
    time: str


@dataclass
class ConfigService:
    client_id = &#34;tmt-frontend-app&#34;
    user = &#34;config-admin1&#34;
    password = &#34;config-admin1&#34;
    _locationService = LocationService()

    def _getBaseUri(self) -&gt; str:
        prefix = Prefix(Subsystems.CSW, &#34;ConfigServer&#34;)
        connection = ConnectionInfo.make(prefix, ComponentType.Service, ConnectionType.HttpType)
        location = self._locationService.resolve(connection)
        if location is not None:
            location.__class__ = HttpLocation
            return location.uri
        raise RuntimeError(&#34;Can&#39;t locate CSW Config Service&#34;)

    def _endPoint(self, path: str) -&gt; str:
        return f&#39;{self._getBaseUri()}{path}&#39;

    def _locateAuthService(self) -&gt; str:
        connection = ConnectionInfo.make(Prefix(Subsystems.CSW, &#34;AAS&#34;), ComponentType.Service, ConnectionType.HttpType)
        location = self._locationService.resolve(connection)
        if location is not None:
            location.__class__ = HttpLocation
            return location.uri
        raise RuntimeError(&#34;Can&#39;t locate CSW Auth Service&#34;)

    def _getToken(self):
        uri = self._locateAuthService()
        keycloak_openid = KeycloakOpenID(server_url=f&#39;{uri}/&#39;,
                                         client_id=self.client_id,
                                         realm_name=&#39;TMT&#39;)
        d = keycloak_openid.token(self.user, self.password)
        return d[&#39;access_token&#39;]

    @staticmethod
    def _validatePath(path: str):
        invalidChars = &#34;!#&lt;&gt;$%&amp;&#39;@^`~+,;=\\s&#34;
        if re.match(invalidChars, path):
            charsMessage = invalidChars.replace(&#39;\\s&#39;, &#39;&#39;)
            raise RuntimeError(
                f&#34;Input file path &#39;{path}&#39; contains invalid characters. &#34;
                + f&#34;Note, these characters {charsMessage} or &#39;white space&#39; are not allowed in file path`&#34;)

    def _createOrUpdate(self, create: bool, path: str, configData: ConfigData,
                        annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        self._validatePath(path)
        token = self._getToken()
        params = urlencode({&#39;annex&#39;: annex, &#39;comment&#39;: comment})
        baseUri = self._endPoint(f&#39;config/{path}&#39;)
        uri = f&#39;{baseUri}?{params}&#39;
        headers = {&#39;Content-type&#39;: &#39;application/octet-stream&#39;, &#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        if create:
            response = requests.post(uri, headers=headers, data=configData.content)
        else:
            response = requests.put(uri, headers=headers, data=configData.content)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigId(response.json())

    def create(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        &#34;&#34;&#34;
        Creates a file at a specified path with given data and comment.

        Args:
            path (str): the file path relative to the repository root
            configData (ConfigData): contents of the file
            annex (bool): true if the file is annex and requires special handling (external storage)
            comment (str): comment to associate with this operation

        Returns: id of file revision
        &#34;&#34;&#34;
        return self._createOrUpdate(True, path, configData, annex, comment)

    def update(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        &#34;&#34;&#34;
        Updates a file at a specified path with given data and comment.

        Args:
            path (str): the file path relative to the repository root
            configData (ConfigData): contents of the file
            annex (bool): true if the file is annex and requires special handling (external storage)
            comment (str): comment to associate with this operation

        Returns: id of file revision
        &#34;&#34;&#34;
        return self._createOrUpdate(False, path, configData, annex, comment)

    def delete(self, path: str, comment: str = &#34;Deleted&#34;):
        &#34;&#34;&#34;
        Deletes the given config file (older versions will still be available).

        Args:
            path: the file path relative to the repository root
            comment: comment to associate with this operation
        &#34;&#34;&#34;
        token = self._getToken()
        params = urlencode({&#39;comment&#39;: comment})
        baseUri = self._endPoint(f&#39;config/{path}&#39;)
        uri = f&#39;{baseUri}?{params}&#39;
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        response = requests.delete(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(response.text)

    def list(self, fileType: FileType = None, pattern: str = None) -&gt; List[ConfigFileInfo]:
        &#34;&#34;&#34;
        Returns a list containing all of the known config files of given type(Annex or Normal) and whose name matches the provided pattern.

        Args:
            fileType: optional file type(Annex or Normal)
            pattern: optional pattern to match against the file name

        Returns: list of ConfigFileInfo

        &#34;&#34;&#34;
        params = {}
        if fileType:
            params.update({&#39;type&#39;: fileType.name})
        if pattern:
            params.update({&#39;pattern&#39;: pattern})
        uri = f&#34;{self._endPoint(&#39;list&#39;)}?{urlencode(params)}&#34;
        response = requests.get(uri)
        return list(map(lambda p: ConfigFileInfo.from_dict(p), response.json()))

    def exists(self, path: str, configId: ConfigId = None):
        &#34;&#34;&#34;
        Returns true if the given path exists and is being managed.

        Args:
            path: the file path relative to the repository root
            configId: revision of the file

        Returns: true if the file exists in the repo
        &#34;&#34;&#34;
        params = {}
        if configId:
            params.update({&#39;id&#39;: configId.id})
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.head(uri)
        return response.ok

    def getLatest(self, path: str) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the content of latest version of the file stored under the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: file contents
        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getById(self, path: str, configId: ConfigId) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the file at the given path with the specified revision id

        Args:
            path (str): the file path relative to the repository root
            configId (ConfigId):  id used to specify a specific version to fetch

        Returns: file contents
        &#34;&#34;&#34;
        params = {&#39;id&#39;: configId.id}
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getByTime(self, path: str, time: datetime) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets the file at the given path as it existed on the given instant.
        If instant is before the file was created, the initial version is returned.
        If instant is after the last change, the most recent version is returned.

        Args:
            path (str): the file path relative to the repository root
            time (datetime): the target instant

        Returns: file contents
        &#34;&#34;&#34;
        params = {&#39;date&#39;: time.isoformat()}
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getActive(self, path: str) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the content of active version of the file stored under the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: file contents

        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;active-config&#39;)}/{path}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getActiveByTime(self, path: str, time: datetime) -&gt; ConfigData:
        &#34;&#34;&#34;
        Returns the content of active version of the file at the given path as it existed on the given instant

        Args:
            path (str): the file path relative to the repository root
            time (datetime): the target instant

        Returns: file contents

        &#34;&#34;&#34;
        params = {&#39;date&#39;: time.isoformat()}
        uri = f&#34;{self._endPoint(&#39;active-config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getActiveVersion(self, path: str) -&gt; ConfigId:
        &#34;&#34;&#34;
        Returns the version which represents the &#34;active version&#34; of the file at the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: ConfigId indicating the id of the active version

        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigId(response.json())

    def getMetadata(self) -&gt; ConfigMetadata:
        &#34;&#34;&#34;
        Query the metadata of config server.
        Returns: a ConfigMetadata object

        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;metadata&#39;)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigMetadata.from_dict(response.json())

    def _history(self, key: str, path: str,
                 fromTime: datetime, toTime: datetime,
                 maxResults: int) -&gt; List[ConfigFileRevision]:
        params = {}
        if fromTime:
            params.update({&#39;from&#39;: fromTime.isoformat()})
        if toTime:
            params.update({&#39;to&#39;: toTime.isoformat()})
        if maxResults:
            params.update({&#39;maxResults&#39;: maxResults})
        uri = f&#34;{self._endPoint(key)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return list(map(lambda p: ConfigFileRevision.from_dict(p), response.json()))

    def history(self, path: str,
                fromTime: datetime = None, toTime: datetime = None,
                maxResults: int = 10000) -&gt; List[ConfigFileRevision]:
        &#34;&#34;&#34;
        Returns the history of versions of the file at the given path for a range of period specified by from and to.
        The size of the list is limited upto maxResults.

        Args:
            path: the file path relative to the repository root
            fromTime: optional start of the history range
            toTime: optional end of the history range
            maxResults: optional maximum number of history results to return (default: unlimited)

        Returns: list of ConfigFileRevision

        &#34;&#34;&#34;
        return self._history(&#39;history&#39;, path, fromTime, toTime, maxResults)

    def historyActive(self, path: str,
                      fromTime: datetime = None, toTime: datetime = None,
                      maxResults: int = None) -&gt; List[ConfigFileRevision]:
        &#34;&#34;&#34;
        Returns the history of active versions of the file at the given path for a range of period specified by
        fromTime and toTime. The size of the list is limited upto maxResults.

        Args:
            path: the file path relative to the repository root
            fromTime: optional start of the history range
            toTime: optional end of the history range
            maxResults: optional maximum number of history results to return (default: unlimited)

        Returns: list of ConfigFileRevision

        &#34;&#34;&#34;
        return self._history(&#39;history-active&#39;, path, fromTime, toTime, maxResults)

    def setActiveVersion(self, path: str, configId: ConfigId, comment: str):
        &#34;&#34;&#34;
        Sets the active version to be the version provided for the file at the given path.
        If this method is not called, the active version will always be the version with which the file was created.
        After calling this method, the version with the given Id will be the active version.

        Args:
            path: the file path relative to the repository root
            configId: an id used to specify a specific version (by default the id of the version with which
                      the file was created i.e. 1)
            comment: comment to associate with this operation

        &#34;&#34;&#34;
        token = self._getToken()
        params = {&#39;id&#39;: configId.id, &#39;comment&#39;: comment}
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.put(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(response.text)

    def resetActiveVersion(self, path: str, comment: str):
        &#34;&#34;&#34;
        Resets the &#34;active version&#34; of the file at the given path to the latest version.

        Args:
            path: the file path relative to the repository root
            comment: comment to associate with this operation

        &#34;&#34;&#34;
        token = self._getToken()
        params = {&#39;comment&#39;: comment}
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.put(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(response.text)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="csw.ConfigService.ConfigData"><code class="flex name class">
<span>class <span class="ident">ConfigData</span></span>
<span>(</span><span>content: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the contents of a file in the Config Service.
You can get the content as a string with <code>s = configData.content.decode('utf-8')</code>.
Create from a string with <code>ConfigData(bytes('hello', 'utf-8'))</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ConfigData:
    &#34;&#34;&#34;
    Represents the contents of a file in the Config Service.
    You can get the content as a string with `s = configData.content.decode(&#39;utf-8&#39;)`.
    Create from a string with `ConfigData(bytes(&#39;hello&#39;, &#39;utf-8&#39;))`.
    &#34;&#34;&#34;
    content: bytes</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigData.content"><code class="name">var <span class="ident">content</span> : bytes</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo"><code class="flex name class">
<span>class <span class="ident">ConfigFileInfo</span></span>
<span>(</span><span>path: str, id: str, author: str, comment: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information about a config file stored in the config service</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigFileInfo:
    &#34;&#34;&#34;
    Contains information about a config file stored in the config service
    &#34;&#34;&#34;
    path: str
    id: str
    author: str
    comment: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileInfo.author"><code class="name">var <span class="ident">author</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.comment"><code class="name">var <span class="ident">comment</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.path"><code class="name">var <span class="ident">path</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileInfo.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: Union[dict, list, str, int, float, bool, ForwardRef(None)], *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls: Type[A],
              kvs: Json,
              *,
              infer_missing=False) -&gt; A:
    return _decode_dataclass(cls, kvs, infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: Union[str, bytes, bytearray], *, parse_float=None, parse_int=None, parse_constant=None, infer_missing=False, **kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls: Type[A],
              s: JsonData,
              *,
              parse_float=None,
              parse_int=None,
              parse_constant=None,
              infer_missing=False,
              **kw) -&gt; A:
    kvs = json.loads(s,
                     parse_float=parse_float,
                     parse_int=parse_int,
                     parse_constant=parse_constant,
                     **kw)
    return cls.from_dict(kvs, infer_missing=infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*, infer_missing: bool = False, only=None, exclude=(), many: bool = False, context=None, load_only=(), dump_only=(), partial: bool = False, unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls: Type[A],
           *,
           infer_missing: bool = False,
           only=None,
           exclude=(),
           many: bool = False,
           context=None,
           load_only=(),
           dump_only=(),
           partial: bool = False,
           unknown=None) -&gt; SchemaType:
    Schema = build_schema(cls, DataClassJsonMixin, infer_missing, partial)

    if unknown is None:
        undefined_parameter_action = _undefined_parameter_action_safe(cls)
        if undefined_parameter_action is not None:
            # We can just make use of the same-named mm keywords
            unknown = undefined_parameter_action.name.lower()

    return Schema(only=only,
                  exclude=exclude,
                  many=many,
                  context=context,
                  load_only=load_only,
                  dump_only=dump_only,
                  partial=partial,
                  unknown=unknown)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileInfo.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, Union[dict, list, str, int, float, bool, ForwardRef(None)]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, ForwardRef(None)] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Tuple[str, str] = None,
            default: Callable = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision"><code class="flex name class">
<span>class <span class="ident">ConfigFileRevision</span></span>
<span>(</span><span>id: str, author: str, comment: str, time: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds information about a specific version of a config file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigFileRevision:
    &#34;&#34;&#34;
    Holds information about a specific version of a config file
    &#34;&#34;&#34;
    id: str
    author: str
    comment: str
    time: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileRevision.author"><code class="name">var <span class="ident">author</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.comment"><code class="name">var <span class="ident">comment</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.time"><code class="name">var <span class="ident">time</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileRevision.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: Union[dict, list, str, int, float, bool, ForwardRef(None)], *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls: Type[A],
              kvs: Json,
              *,
              infer_missing=False) -&gt; A:
    return _decode_dataclass(cls, kvs, infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: Union[str, bytes, bytearray], *, parse_float=None, parse_int=None, parse_constant=None, infer_missing=False, **kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls: Type[A],
              s: JsonData,
              *,
              parse_float=None,
              parse_int=None,
              parse_constant=None,
              infer_missing=False,
              **kw) -&gt; A:
    kvs = json.loads(s,
                     parse_float=parse_float,
                     parse_int=parse_int,
                     parse_constant=parse_constant,
                     **kw)
    return cls.from_dict(kvs, infer_missing=infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*, infer_missing: bool = False, only=None, exclude=(), many: bool = False, context=None, load_only=(), dump_only=(), partial: bool = False, unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls: Type[A],
           *,
           infer_missing: bool = False,
           only=None,
           exclude=(),
           many: bool = False,
           context=None,
           load_only=(),
           dump_only=(),
           partial: bool = False,
           unknown=None) -&gt; SchemaType:
    Schema = build_schema(cls, DataClassJsonMixin, infer_missing, partial)

    if unknown is None:
        undefined_parameter_action = _undefined_parameter_action_safe(cls)
        if undefined_parameter_action is not None:
            # We can just make use of the same-named mm keywords
            unknown = undefined_parameter_action.name.lower()

    return Schema(only=only,
                  exclude=exclude,
                  many=many,
                  context=context,
                  load_only=load_only,
                  dump_only=dump_only,
                  partial=partial,
                  unknown=unknown)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileRevision.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, Union[dict, list, str, int, float, bool, ForwardRef(None)]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, ForwardRef(None)] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Tuple[str, str] = None,
            default: Callable = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigId"><code class="flex name class">
<span>class <span class="ident">ConfigId</span></span>
<span>(</span><span>id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Type of an id returned from ConfigManager create or update methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigId:
    &#34;&#34;&#34;
    Type of an id returned from ConfigManager create or update methods
    &#34;&#34;&#34;
    id: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigId.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigId.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: Union[dict, list, str, int, float, bool, ForwardRef(None)], *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls: Type[A],
              kvs: Json,
              *,
              infer_missing=False) -&gt; A:
    return _decode_dataclass(cls, kvs, infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigId.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: Union[str, bytes, bytearray], *, parse_float=None, parse_int=None, parse_constant=None, infer_missing=False, **kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls: Type[A],
              s: JsonData,
              *,
              parse_float=None,
              parse_int=None,
              parse_constant=None,
              infer_missing=False,
              **kw) -&gt; A:
    kvs = json.loads(s,
                     parse_float=parse_float,
                     parse_int=parse_int,
                     parse_constant=parse_constant,
                     **kw)
    return cls.from_dict(kvs, infer_missing=infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigId.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*, infer_missing: bool = False, only=None, exclude=(), many: bool = False, context=None, load_only=(), dump_only=(), partial: bool = False, unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls: Type[A],
           *,
           infer_missing: bool = False,
           only=None,
           exclude=(),
           many: bool = False,
           context=None,
           load_only=(),
           dump_only=(),
           partial: bool = False,
           unknown=None) -&gt; SchemaType:
    Schema = build_schema(cls, DataClassJsonMixin, infer_missing, partial)

    if unknown is None:
        undefined_parameter_action = _undefined_parameter_action_safe(cls)
        if undefined_parameter_action is not None:
            # We can just make use of the same-named mm keywords
            unknown = undefined_parameter_action.name.lower()

    return Schema(only=only,
                  exclude=exclude,
                  many=many,
                  context=context,
                  load_only=load_only,
                  dump_only=dump_only,
                  partial=partial,
                  unknown=unknown)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigId.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, Union[dict, list, str, int, float, bool, ForwardRef(None)]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigId.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, ForwardRef(None)] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Tuple[str, str] = None,
            default: Callable = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigMetadata"><code class="flex name class">
<span>class <span class="ident">ConfigMetadata</span></span>
<span>(</span><span>repoPath: str, annexPath: str, annexMinFileSize: str, maxConfigFileSize: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds metadata information about config server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigMetadata:
    &#34;&#34;&#34;
    Holds metadata information about config server
    &#34;&#34;&#34;
    repoPath: str
    annexPath: str
    annexMinFileSize: str
    maxConfigFileSize: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigMetadata.annexMinFileSize"><code class="name">var <span class="ident">annexMinFileSize</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.annexPath"><code class="name">var <span class="ident">annexPath</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.maxConfigFileSize"><code class="name">var <span class="ident">maxConfigFileSize</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.repoPath"><code class="name">var <span class="ident">repoPath</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigMetadata.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: Union[dict, list, str, int, float, bool, ForwardRef(None)], *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls: Type[A],
              kvs: Json,
              *,
              infer_missing=False) -&gt; A:
    return _decode_dataclass(cls, kvs, infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: Union[str, bytes, bytearray], *, parse_float=None, parse_int=None, parse_constant=None, infer_missing=False, **kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls: Type[A],
              s: JsonData,
              *,
              parse_float=None,
              parse_int=None,
              parse_constant=None,
              infer_missing=False,
              **kw) -&gt; A:
    kvs = json.loads(s,
                     parse_float=parse_float,
                     parse_int=parse_int,
                     parse_constant=parse_constant,
                     **kw)
    return cls.from_dict(kvs, infer_missing=infer_missing)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*, infer_missing: bool = False, only=None, exclude=(), many: bool = False, context=None, load_only=(), dump_only=(), partial: bool = False, unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls: Type[A],
           *,
           infer_missing: bool = False,
           only=None,
           exclude=(),
           many: bool = False,
           context=None,
           load_only=(),
           dump_only=(),
           partial: bool = False,
           unknown=None) -&gt; SchemaType:
    Schema = build_schema(cls, DataClassJsonMixin, infer_missing, partial)

    if unknown is None:
        undefined_parameter_action = _undefined_parameter_action_safe(cls)
        if undefined_parameter_action is not None:
            # We can just make use of the same-named mm keywords
            unknown = undefined_parameter_action.name.lower()

    return Schema(only=only,
                  exclude=exclude,
                  many=many,
                  context=context,
                  load_only=load_only,
                  dump_only=dump_only,
                  partial=partial,
                  unknown=unknown)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigMetadata.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, Union[dict, list, str, int, float, bool, ForwardRef(None)]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, ForwardRef(None)] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Tuple[str, str] = None,
            default: Callable = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigService"><code class="flex name class">
<span>class <span class="ident">ConfigService</span></span>
</code></dt>
<dd>
<div class="desc"><p>ConfigService()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ConfigService:
    client_id = &#34;tmt-frontend-app&#34;
    user = &#34;config-admin1&#34;
    password = &#34;config-admin1&#34;
    _locationService = LocationService()

    def _getBaseUri(self) -&gt; str:
        prefix = Prefix(Subsystems.CSW, &#34;ConfigServer&#34;)
        connection = ConnectionInfo.make(prefix, ComponentType.Service, ConnectionType.HttpType)
        location = self._locationService.resolve(connection)
        if location is not None:
            location.__class__ = HttpLocation
            return location.uri
        raise RuntimeError(&#34;Can&#39;t locate CSW Config Service&#34;)

    def _endPoint(self, path: str) -&gt; str:
        return f&#39;{self._getBaseUri()}{path}&#39;

    def _locateAuthService(self) -&gt; str:
        connection = ConnectionInfo.make(Prefix(Subsystems.CSW, &#34;AAS&#34;), ComponentType.Service, ConnectionType.HttpType)
        location = self._locationService.resolve(connection)
        if location is not None:
            location.__class__ = HttpLocation
            return location.uri
        raise RuntimeError(&#34;Can&#39;t locate CSW Auth Service&#34;)

    def _getToken(self):
        uri = self._locateAuthService()
        keycloak_openid = KeycloakOpenID(server_url=f&#39;{uri}/&#39;,
                                         client_id=self.client_id,
                                         realm_name=&#39;TMT&#39;)
        d = keycloak_openid.token(self.user, self.password)
        return d[&#39;access_token&#39;]

    @staticmethod
    def _validatePath(path: str):
        invalidChars = &#34;!#&lt;&gt;$%&amp;&#39;@^`~+,;=\\s&#34;
        if re.match(invalidChars, path):
            charsMessage = invalidChars.replace(&#39;\\s&#39;, &#39;&#39;)
            raise RuntimeError(
                f&#34;Input file path &#39;{path}&#39; contains invalid characters. &#34;
                + f&#34;Note, these characters {charsMessage} or &#39;white space&#39; are not allowed in file path`&#34;)

    def _createOrUpdate(self, create: bool, path: str, configData: ConfigData,
                        annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        self._validatePath(path)
        token = self._getToken()
        params = urlencode({&#39;annex&#39;: annex, &#39;comment&#39;: comment})
        baseUri = self._endPoint(f&#39;config/{path}&#39;)
        uri = f&#39;{baseUri}?{params}&#39;
        headers = {&#39;Content-type&#39;: &#39;application/octet-stream&#39;, &#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        if create:
            response = requests.post(uri, headers=headers, data=configData.content)
        else:
            response = requests.put(uri, headers=headers, data=configData.content)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigId(response.json())

    def create(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        &#34;&#34;&#34;
        Creates a file at a specified path with given data and comment.

        Args:
            path (str): the file path relative to the repository root
            configData (ConfigData): contents of the file
            annex (bool): true if the file is annex and requires special handling (external storage)
            comment (str): comment to associate with this operation

        Returns: id of file revision
        &#34;&#34;&#34;
        return self._createOrUpdate(True, path, configData, annex, comment)

    def update(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        &#34;&#34;&#34;
        Updates a file at a specified path with given data and comment.

        Args:
            path (str): the file path relative to the repository root
            configData (ConfigData): contents of the file
            annex (bool): true if the file is annex and requires special handling (external storage)
            comment (str): comment to associate with this operation

        Returns: id of file revision
        &#34;&#34;&#34;
        return self._createOrUpdate(False, path, configData, annex, comment)

    def delete(self, path: str, comment: str = &#34;Deleted&#34;):
        &#34;&#34;&#34;
        Deletes the given config file (older versions will still be available).

        Args:
            path: the file path relative to the repository root
            comment: comment to associate with this operation
        &#34;&#34;&#34;
        token = self._getToken()
        params = urlencode({&#39;comment&#39;: comment})
        baseUri = self._endPoint(f&#39;config/{path}&#39;)
        uri = f&#39;{baseUri}?{params}&#39;
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        response = requests.delete(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(response.text)

    def list(self, fileType: FileType = None, pattern: str = None) -&gt; List[ConfigFileInfo]:
        &#34;&#34;&#34;
        Returns a list containing all of the known config files of given type(Annex or Normal) and whose name matches the provided pattern.

        Args:
            fileType: optional file type(Annex or Normal)
            pattern: optional pattern to match against the file name

        Returns: list of ConfigFileInfo

        &#34;&#34;&#34;
        params = {}
        if fileType:
            params.update({&#39;type&#39;: fileType.name})
        if pattern:
            params.update({&#39;pattern&#39;: pattern})
        uri = f&#34;{self._endPoint(&#39;list&#39;)}?{urlencode(params)}&#34;
        response = requests.get(uri)
        return list(map(lambda p: ConfigFileInfo.from_dict(p), response.json()))

    def exists(self, path: str, configId: ConfigId = None):
        &#34;&#34;&#34;
        Returns true if the given path exists and is being managed.

        Args:
            path: the file path relative to the repository root
            configId: revision of the file

        Returns: true if the file exists in the repo
        &#34;&#34;&#34;
        params = {}
        if configId:
            params.update({&#39;id&#39;: configId.id})
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.head(uri)
        return response.ok

    def getLatest(self, path: str) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the content of latest version of the file stored under the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: file contents
        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getById(self, path: str, configId: ConfigId) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the file at the given path with the specified revision id

        Args:
            path (str): the file path relative to the repository root
            configId (ConfigId):  id used to specify a specific version to fetch

        Returns: file contents
        &#34;&#34;&#34;
        params = {&#39;id&#39;: configId.id}
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getByTime(self, path: str, time: datetime) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets the file at the given path as it existed on the given instant.
        If instant is before the file was created, the initial version is returned.
        If instant is after the last change, the most recent version is returned.

        Args:
            path (str): the file path relative to the repository root
            time (datetime): the target instant

        Returns: file contents
        &#34;&#34;&#34;
        params = {&#39;date&#39;: time.isoformat()}
        uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getActive(self, path: str) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the content of active version of the file stored under the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: file contents

        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;active-config&#39;)}/{path}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getActiveByTime(self, path: str, time: datetime) -&gt; ConfigData:
        &#34;&#34;&#34;
        Returns the content of active version of the file at the given path as it existed on the given instant

        Args:
            path (str): the file path relative to the repository root
            time (datetime): the target instant

        Returns: file contents

        &#34;&#34;&#34;
        params = {&#39;date&#39;: time.isoformat()}
        uri = f&#34;{self._endPoint(&#39;active-config&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigData(response.content)

    def getActiveVersion(self, path: str) -&gt; ConfigId:
        &#34;&#34;&#34;
        Returns the version which represents the &#34;active version&#34; of the file at the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: ConfigId indicating the id of the active version

        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigId(response.json())

    def getMetadata(self) -&gt; ConfigMetadata:
        &#34;&#34;&#34;
        Query the metadata of config server.
        Returns: a ConfigMetadata object

        &#34;&#34;&#34;
        uri = f&#34;{self._endPoint(&#39;metadata&#39;)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return ConfigMetadata.from_dict(response.json())

    def _history(self, key: str, path: str,
                 fromTime: datetime, toTime: datetime,
                 maxResults: int) -&gt; List[ConfigFileRevision]:
        params = {}
        if fromTime:
            params.update({&#39;from&#39;: fromTime.isoformat()})
        if toTime:
            params.update({&#39;to&#39;: toTime.isoformat()})
        if maxResults:
            params.update({&#39;maxResults&#39;: maxResults})
        uri = f&#34;{self._endPoint(key)}/{path}?{urlencode(params)}&#34;
        response = requests.get(uri)
        if not response.ok:
            raise RuntimeError(response.text)
        return list(map(lambda p: ConfigFileRevision.from_dict(p), response.json()))

    def history(self, path: str,
                fromTime: datetime = None, toTime: datetime = None,
                maxResults: int = 10000) -&gt; List[ConfigFileRevision]:
        &#34;&#34;&#34;
        Returns the history of versions of the file at the given path for a range of period specified by from and to.
        The size of the list is limited upto maxResults.

        Args:
            path: the file path relative to the repository root
            fromTime: optional start of the history range
            toTime: optional end of the history range
            maxResults: optional maximum number of history results to return (default: unlimited)

        Returns: list of ConfigFileRevision

        &#34;&#34;&#34;
        return self._history(&#39;history&#39;, path, fromTime, toTime, maxResults)

    def historyActive(self, path: str,
                      fromTime: datetime = None, toTime: datetime = None,
                      maxResults: int = None) -&gt; List[ConfigFileRevision]:
        &#34;&#34;&#34;
        Returns the history of active versions of the file at the given path for a range of period specified by
        fromTime and toTime. The size of the list is limited upto maxResults.

        Args:
            path: the file path relative to the repository root
            fromTime: optional start of the history range
            toTime: optional end of the history range
            maxResults: optional maximum number of history results to return (default: unlimited)

        Returns: list of ConfigFileRevision

        &#34;&#34;&#34;
        return self._history(&#39;history-active&#39;, path, fromTime, toTime, maxResults)

    def setActiveVersion(self, path: str, configId: ConfigId, comment: str):
        &#34;&#34;&#34;
        Sets the active version to be the version provided for the file at the given path.
        If this method is not called, the active version will always be the version with which the file was created.
        After calling this method, the version with the given Id will be the active version.

        Args:
            path: the file path relative to the repository root
            configId: an id used to specify a specific version (by default the id of the version with which
                      the file was created i.e. 1)
            comment: comment to associate with this operation

        &#34;&#34;&#34;
        token = self._getToken()
        params = {&#39;id&#39;: configId.id, &#39;comment&#39;: comment}
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.put(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(response.text)

    def resetActiveVersion(self, path: str, comment: str):
        &#34;&#34;&#34;
        Resets the &#34;active version&#34; of the file at the given path to the latest version.

        Args:
            path: the file path relative to the repository root
            comment: comment to associate with this operation

        &#34;&#34;&#34;
        token = self._getToken()
        params = {&#39;comment&#39;: comment}
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
        response = requests.put(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(response.text)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigService.client_id"><code class="name">var <span class="ident">client_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigService.password"><code class="name">var <span class="ident">password</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigService.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigService.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, path: str, configData: <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a>, annex: bool = False, comment: str = 'Created') ‑> <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a file at a specified path with given data and comment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configData</code></strong> :&ensp;<code><a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></code></dt>
<dd>contents of the file</dd>
<dt><strong><code>annex</code></strong> :&ensp;<code>bool</code></dt>
<dd>true if the file is annex and requires special handling (external storage)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>comment to associate with this operation</dd>
</dl>
<p>Returns: id of file revision</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
    &#34;&#34;&#34;
    Creates a file at a specified path with given data and comment.

    Args:
        path (str): the file path relative to the repository root
        configData (ConfigData): contents of the file
        annex (bool): true if the file is annex and requires special handling (external storage)
        comment (str): comment to associate with this operation

    Returns: id of file revision
    &#34;&#34;&#34;
    return self._createOrUpdate(True, path, configData, annex, comment)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, path: str, comment: str = 'Deleted')</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the given config file (older versions will still be available).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>comment to associate with this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, path: str, comment: str = &#34;Deleted&#34;):
    &#34;&#34;&#34;
    Deletes the given config file (older versions will still be available).

    Args:
        path: the file path relative to the repository root
        comment: comment to associate with this operation
    &#34;&#34;&#34;
    token = self._getToken()
    params = urlencode({&#39;comment&#39;: comment})
    baseUri = self._endPoint(f&#39;config/{path}&#39;)
    uri = f&#39;{baseUri}?{params}&#39;
    headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
    response = requests.delete(uri, headers=headers)
    if not response.ok:
        raise RuntimeError(response.text)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, path: str, configId: <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the given path exists and is being managed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configId</code></strong></dt>
<dd>revision of the file</dd>
</dl>
<p>Returns: true if the file exists in the repo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, path: str, configId: ConfigId = None):
    &#34;&#34;&#34;
    Returns true if the given path exists and is being managed.

    Args:
        path: the file path relative to the repository root
        configId: revision of the file

    Returns: true if the file exists in the repo
    &#34;&#34;&#34;
    params = {}
    if configId:
        params.update({&#39;id&#39;: configId.id})
    uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
    response = requests.head(uri)
    return response.ok</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.getActive"><code class="name flex">
<span>def <span class="ident">getActive</span></span>(<span>self, path: str) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets and returns the content of active version of the file stored under the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
</dl>
<p>Returns: file contents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActive(self, path: str) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets and returns the content of active version of the file stored under the given path.

    Args:
        path (str): the file path relative to the repository root

    Returns: file contents

    &#34;&#34;&#34;
    uri = f&#34;{self._endPoint(&#39;active-config&#39;)}/{path}&#34;
    response = requests.get(uri)
    if not response.ok:
        raise RuntimeError(response.text)
    return ConfigData(response.content)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.getActiveByTime"><code class="name flex">
<span>def <span class="ident">getActiveByTime</span></span>(<span>self, path: str, time: datetime.datetime) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the content of active version of the file at the given path as it existed on the given instant</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>the target instant</dd>
</dl>
<p>Returns: file contents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveByTime(self, path: str, time: datetime) -&gt; ConfigData:
    &#34;&#34;&#34;
    Returns the content of active version of the file at the given path as it existed on the given instant

    Args:
        path (str): the file path relative to the repository root
        time (datetime): the target instant

    Returns: file contents

    &#34;&#34;&#34;
    params = {&#39;date&#39;: time.isoformat()}
    uri = f&#34;{self._endPoint(&#39;active-config&#39;)}/{path}?{urlencode(params)}&#34;
    response = requests.get(uri)
    if not response.ok:
        raise RuntimeError(response.text)
    return ConfigData(response.content)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.getActiveVersion"><code class="name flex">
<span>def <span class="ident">getActiveVersion</span></span>(<span>self, path: str) ‑> <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the version which represents the "active version" of the file at the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
</dl>
<p>Returns: ConfigId indicating the id of the active version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveVersion(self, path: str) -&gt; ConfigId:
    &#34;&#34;&#34;
    Returns the version which represents the &#34;active version&#34; of the file at the given path.

    Args:
        path (str): the file path relative to the repository root

    Returns: ConfigId indicating the id of the active version

    &#34;&#34;&#34;
    uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}&#34;
    response = requests.get(uri)
    if not response.ok:
        raise RuntimeError(response.text)
    return ConfigId(response.json())</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.getById"><code class="name flex">
<span>def <span class="ident">getById</span></span>(<span>self, path: str, configId: <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a>) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets and returns the file at the given path with the specified revision id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configId</code></strong> :&ensp;<code><a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></code></dt>
<dd>id used to specify a specific version to fetch</dd>
</dl>
<p>Returns: file contents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getById(self, path: str, configId: ConfigId) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets and returns the file at the given path with the specified revision id

    Args:
        path (str): the file path relative to the repository root
        configId (ConfigId):  id used to specify a specific version to fetch

    Returns: file contents
    &#34;&#34;&#34;
    params = {&#39;id&#39;: configId.id}
    uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
    response = requests.get(uri)
    if not response.ok:
        raise RuntimeError(response.text)
    return ConfigData(response.content)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.getByTime"><code class="name flex">
<span>def <span class="ident">getByTime</span></span>(<span>self, path: str, time: datetime.datetime) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets the file at the given path as it existed on the given instant.
If instant is before the file was created, the initial version is returned.
If instant is after the last change, the most recent version is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>the target instant</dd>
</dl>
<p>Returns: file contents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getByTime(self, path: str, time: datetime) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets the file at the given path as it existed on the given instant.
    If instant is before the file was created, the initial version is returned.
    If instant is after the last change, the most recent version is returned.

    Args:
        path (str): the file path relative to the repository root
        time (datetime): the target instant

    Returns: file contents
    &#34;&#34;&#34;
    params = {&#39;date&#39;: time.isoformat()}
    uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
    response = requests.get(uri)
    if not response.ok:
        raise RuntimeError(response.text)
    return ConfigData(response.content)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.getLatest"><code class="name flex">
<span>def <span class="ident">getLatest</span></span>(<span>self, path: str) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets and returns the content of latest version of the file stored under the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
</dl>
<p>Returns: file contents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLatest(self, path: str) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets and returns the content of latest version of the file stored under the given path.

    Args:
        path (str): the file path relative to the repository root

    Returns: file contents
    &#34;&#34;&#34;
    uri = f&#34;{self._endPoint(&#39;config&#39;)}/{path}&#34;
    response = requests.get(uri)
    if not response.ok:
        raise RuntimeError(response.text)
    return ConfigData(response.content)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.getMetadata"><code class="name flex">
<span>def <span class="ident">getMetadata</span></span>(<span>self) ‑> <a title="csw.ConfigService.ConfigMetadata" href="#csw.ConfigService.ConfigMetadata">ConfigMetadata</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query the metadata of config server.
Returns: a ConfigMetadata object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMetadata(self) -&gt; ConfigMetadata:
    &#34;&#34;&#34;
    Query the metadata of config server.
    Returns: a ConfigMetadata object

    &#34;&#34;&#34;
    uri = f&#34;{self._endPoint(&#39;metadata&#39;)}&#34;
    response = requests.get(uri)
    if not response.ok:
        raise RuntimeError(response.text)
    return ConfigMetadata.from_dict(response.json())</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.history"><code class="name flex">
<span>def <span class="ident">history</span></span>(<span>self, path: str, fromTime: datetime.datetime = None, toTime: datetime.datetime = None, maxResults: int = 10000) ‑> List[<a title="csw.ConfigService.ConfigFileRevision" href="#csw.ConfigService.ConfigFileRevision">ConfigFileRevision</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the history of versions of the file at the given path for a range of period specified by from and to.
The size of the list is limited upto maxResults.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>fromTime</code></strong></dt>
<dd>optional start of the history range</dd>
<dt><strong><code>toTime</code></strong></dt>
<dd>optional end of the history range</dd>
<dt><strong><code>maxResults</code></strong></dt>
<dd>optional maximum number of history results to return (default: unlimited)</dd>
</dl>
<p>Returns: list of ConfigFileRevision</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def history(self, path: str,
            fromTime: datetime = None, toTime: datetime = None,
            maxResults: int = 10000) -&gt; List[ConfigFileRevision]:
    &#34;&#34;&#34;
    Returns the history of versions of the file at the given path for a range of period specified by from and to.
    The size of the list is limited upto maxResults.

    Args:
        path: the file path relative to the repository root
        fromTime: optional start of the history range
        toTime: optional end of the history range
        maxResults: optional maximum number of history results to return (default: unlimited)

    Returns: list of ConfigFileRevision

    &#34;&#34;&#34;
    return self._history(&#39;history&#39;, path, fromTime, toTime, maxResults)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.historyActive"><code class="name flex">
<span>def <span class="ident">historyActive</span></span>(<span>self, path: str, fromTime: datetime.datetime = None, toTime: datetime.datetime = None, maxResults: int = None) ‑> List[<a title="csw.ConfigService.ConfigFileRevision" href="#csw.ConfigService.ConfigFileRevision">ConfigFileRevision</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the history of active versions of the file at the given path for a range of period specified by
fromTime and toTime. The size of the list is limited upto maxResults.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>fromTime</code></strong></dt>
<dd>optional start of the history range</dd>
<dt><strong><code>toTime</code></strong></dt>
<dd>optional end of the history range</dd>
<dt><strong><code>maxResults</code></strong></dt>
<dd>optional maximum number of history results to return (default: unlimited)</dd>
</dl>
<p>Returns: list of ConfigFileRevision</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def historyActive(self, path: str,
                  fromTime: datetime = None, toTime: datetime = None,
                  maxResults: int = None) -&gt; List[ConfigFileRevision]:
    &#34;&#34;&#34;
    Returns the history of active versions of the file at the given path for a range of period specified by
    fromTime and toTime. The size of the list is limited upto maxResults.

    Args:
        path: the file path relative to the repository root
        fromTime: optional start of the history range
        toTime: optional end of the history range
        maxResults: optional maximum number of history results to return (default: unlimited)

    Returns: list of ConfigFileRevision

    &#34;&#34;&#34;
    return self._history(&#39;history-active&#39;, path, fromTime, toTime, maxResults)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, fileType: <a title="csw.ConfigService.FileType" href="#csw.ConfigService.FileType">FileType</a> = None, pattern: str = None) ‑> List[<a title="csw.ConfigService.ConfigFileInfo" href="#csw.ConfigService.ConfigFileInfo">ConfigFileInfo</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list containing all of the known config files of given type(Annex or Normal) and whose name matches the provided pattern.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fileType</code></strong></dt>
<dd>optional file type(Annex or Normal)</dd>
<dt><strong><code>pattern</code></strong></dt>
<dd>optional pattern to match against the file name</dd>
</dl>
<p>Returns: list of ConfigFileInfo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, fileType: FileType = None, pattern: str = None) -&gt; List[ConfigFileInfo]:
    &#34;&#34;&#34;
    Returns a list containing all of the known config files of given type(Annex or Normal) and whose name matches the provided pattern.

    Args:
        fileType: optional file type(Annex or Normal)
        pattern: optional pattern to match against the file name

    Returns: list of ConfigFileInfo

    &#34;&#34;&#34;
    params = {}
    if fileType:
        params.update({&#39;type&#39;: fileType.name})
    if pattern:
        params.update({&#39;pattern&#39;: pattern})
    uri = f&#34;{self._endPoint(&#39;list&#39;)}?{urlencode(params)}&#34;
    response = requests.get(uri)
    return list(map(lambda p: ConfigFileInfo.from_dict(p), response.json()))</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.resetActiveVersion"><code class="name flex">
<span>def <span class="ident">resetActiveVersion</span></span>(<span>self, path: str, comment: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the "active version" of the file at the given path to the latest version.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>comment to associate with this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetActiveVersion(self, path: str, comment: str):
    &#34;&#34;&#34;
    Resets the &#34;active version&#34; of the file at the given path to the latest version.

    Args:
        path: the file path relative to the repository root
        comment: comment to associate with this operation

    &#34;&#34;&#34;
    token = self._getToken()
    params = {&#39;comment&#39;: comment}
    headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
    uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
    response = requests.put(uri, headers=headers)
    if not response.ok:
        raise RuntimeError(response.text)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.setActiveVersion"><code class="name flex">
<span>def <span class="ident">setActiveVersion</span></span>(<span>self, path: str, configId: <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a>, comment: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the active version to be the version provided for the file at the given path.
If this method is not called, the active version will always be the version with which the file was created.
After calling this method, the version with the given Id will be the active version.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configId</code></strong></dt>
<dd>an id used to specify a specific version (by default the id of the version with which
the file was created i.e. 1)</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>comment to associate with this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setActiveVersion(self, path: str, configId: ConfigId, comment: str):
    &#34;&#34;&#34;
    Sets the active version to be the version provided for the file at the given path.
    If this method is not called, the active version will always be the version with which the file was created.
    After calling this method, the version with the given Id will be the active version.

    Args:
        path: the file path relative to the repository root
        configId: an id used to specify a specific version (by default the id of the version with which
                  the file was created i.e. 1)
        comment: comment to associate with this operation

    &#34;&#34;&#34;
    token = self._getToken()
    params = {&#39;id&#39;: configId.id, &#39;comment&#39;: comment}
    headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
    uri = f&#34;{self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
    response = requests.put(uri, headers=headers)
    if not response.ok:
        raise RuntimeError(response.text)</code></pre>
</details>
</dd>
<dt id="csw.ConfigService.ConfigService.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, path: str, configData: <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a>, annex: bool = False, comment: str = 'Created') ‑> <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Updates a file at a specified path with given data and comment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configData</code></strong> :&ensp;<code><a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></code></dt>
<dd>contents of the file</dd>
<dt><strong><code>annex</code></strong> :&ensp;<code>bool</code></dt>
<dd>true if the file is annex and requires special handling (external storage)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>comment to associate with this operation</dd>
</dl>
<p>Returns: id of file revision</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
    &#34;&#34;&#34;
    Updates a file at a specified path with given data and comment.

    Args:
        path (str): the file path relative to the repository root
        configData (ConfigData): contents of the file
        annex (bool): true if the file is annex and requires special handling (external storage)
        comment (str): comment to associate with this operation

    Returns: id of file revision
    &#34;&#34;&#34;
    return self._createOrUpdate(False, path, configData, annex, comment)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.FileType"><code class="flex name class">
<span>class <span class="ident">FileType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the type of storage for a configuration file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileType(Enum):
    &#34;&#34;&#34;
    Represents the type of storage for a configuration file
    &#34;&#34;&#34;
    Normal = 0
    Annex = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.FileType.Annex"><code class="name">var <span class="ident">Annex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.FileType.Normal"><code class="name">var <span class="ident">Normal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="csw" href="index.html">csw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></code></h4>
<ul class="">
<li><code><a title="csw.ConfigService.ConfigData.content" href="#csw.ConfigService.ConfigData.content">content</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigFileInfo" href="#csw.ConfigService.ConfigFileInfo">ConfigFileInfo</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigFileInfo.author" href="#csw.ConfigService.ConfigFileInfo.author">author</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.comment" href="#csw.ConfigService.ConfigFileInfo.comment">comment</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.from_dict" href="#csw.ConfigService.ConfigFileInfo.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.from_json" href="#csw.ConfigService.ConfigFileInfo.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.id" href="#csw.ConfigService.ConfigFileInfo.id">id</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.path" href="#csw.ConfigService.ConfigFileInfo.path">path</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.schema" href="#csw.ConfigService.ConfigFileInfo.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.to_dict" href="#csw.ConfigService.ConfigFileInfo.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.to_json" href="#csw.ConfigService.ConfigFileInfo.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigFileRevision" href="#csw.ConfigService.ConfigFileRevision">ConfigFileRevision</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigFileRevision.author" href="#csw.ConfigService.ConfigFileRevision.author">author</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.comment" href="#csw.ConfigService.ConfigFileRevision.comment">comment</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.from_dict" href="#csw.ConfigService.ConfigFileRevision.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.from_json" href="#csw.ConfigService.ConfigFileRevision.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.id" href="#csw.ConfigService.ConfigFileRevision.id">id</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.schema" href="#csw.ConfigService.ConfigFileRevision.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.time" href="#csw.ConfigService.ConfigFileRevision.time">time</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.to_dict" href="#csw.ConfigService.ConfigFileRevision.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.to_json" href="#csw.ConfigService.ConfigFileRevision.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigId.from_dict" href="#csw.ConfigService.ConfigId.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.from_json" href="#csw.ConfigService.ConfigId.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.id" href="#csw.ConfigService.ConfigId.id">id</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.schema" href="#csw.ConfigService.ConfigId.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.to_dict" href="#csw.ConfigService.ConfigId.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.to_json" href="#csw.ConfigService.ConfigId.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigMetadata" href="#csw.ConfigService.ConfigMetadata">ConfigMetadata</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigMetadata.annexMinFileSize" href="#csw.ConfigService.ConfigMetadata.annexMinFileSize">annexMinFileSize</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.annexPath" href="#csw.ConfigService.ConfigMetadata.annexPath">annexPath</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.from_dict" href="#csw.ConfigService.ConfigMetadata.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.from_json" href="#csw.ConfigService.ConfigMetadata.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.maxConfigFileSize" href="#csw.ConfigService.ConfigMetadata.maxConfigFileSize">maxConfigFileSize</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.repoPath" href="#csw.ConfigService.ConfigMetadata.repoPath">repoPath</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.schema" href="#csw.ConfigService.ConfigMetadata.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.to_dict" href="#csw.ConfigService.ConfigMetadata.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.to_json" href="#csw.ConfigService.ConfigMetadata.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigService" href="#csw.ConfigService.ConfigService">ConfigService</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigService.client_id" href="#csw.ConfigService.ConfigService.client_id">client_id</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.create" href="#csw.ConfigService.ConfigService.create">create</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.delete" href="#csw.ConfigService.ConfigService.delete">delete</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.exists" href="#csw.ConfigService.ConfigService.exists">exists</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getActive" href="#csw.ConfigService.ConfigService.getActive">getActive</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getActiveByTime" href="#csw.ConfigService.ConfigService.getActiveByTime">getActiveByTime</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getActiveVersion" href="#csw.ConfigService.ConfigService.getActiveVersion">getActiveVersion</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getById" href="#csw.ConfigService.ConfigService.getById">getById</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getByTime" href="#csw.ConfigService.ConfigService.getByTime">getByTime</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getLatest" href="#csw.ConfigService.ConfigService.getLatest">getLatest</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getMetadata" href="#csw.ConfigService.ConfigService.getMetadata">getMetadata</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.history" href="#csw.ConfigService.ConfigService.history">history</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.historyActive" href="#csw.ConfigService.ConfigService.historyActive">historyActive</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.list" href="#csw.ConfigService.ConfigService.list">list</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.password" href="#csw.ConfigService.ConfigService.password">password</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.resetActiveVersion" href="#csw.ConfigService.ConfigService.resetActiveVersion">resetActiveVersion</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.setActiveVersion" href="#csw.ConfigService.ConfigService.setActiveVersion">setActiveVersion</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.update" href="#csw.ConfigService.ConfigService.update">update</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.user" href="#csw.ConfigService.ConfigService.user">user</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.FileType" href="#csw.ConfigService.FileType">FileType</a></code></h4>
<ul class="">
<li><code><a title="csw.ConfigService.FileType.Annex" href="#csw.ConfigService.FileType.Annex">Annex</a></code></li>
<li><code><a title="csw.ConfigService.FileType.Normal" href="#csw.ConfigService.FileType.Normal">Normal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>