<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>csw.ConfigService API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>csw.ConfigService</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="csw.ConfigService.ConfigData"><code class="flex name class">
<span>class <span class="ident">ConfigData</span></span>
<span>(</span><span>content: bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ConfigData:
    &#34;&#34;&#34;
    Represents the contents of a file in the Config Service.
    You can get the content as a string with `s = configData.content.decode(&#39;utf-8&#39;)`.
    Create from a string with `ConfigData(bytes(&#39;hello&#39;, &#39;utf-8&#39;))`.
    &#34;&#34;&#34;
    content: bytes

    def __str__(self):
        return self.content.decode(&#39;utf-8&#39;)</code></pre>
</details>
<div class="desc"><p>Represents the contents of a file in the Config Service.
You can get the content as a string with <code>s = configData.content.decode('utf-8')</code>.
Create from a string with <code>ConfigData(bytes('hello', 'utf-8'))</code>.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigData.content"><code class="name">var <span class="ident">content</span> : bytes</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo"><code class="flex name class">
<span>class <span class="ident">ConfigFileInfo</span></span>
<span>(</span><span>path: str, id: str, author: str, comment: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigFileInfo:
    &#34;&#34;&#34;
    Contains information about a config file stored in the config service
    &#34;&#34;&#34;
    path: str
    id: str
    author: str
    comment: str</code></pre>
</details>
<div class="desc"><p>Contains information about a config file stored in the config service</p></div>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileInfo.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: dict | list | str | int | float | bool | None, *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: str | bytes | bytearray,<br>*,<br>parse_float=None,<br>parse_int=None,<br>parse_constant=None,<br>infer_missing=False,<br>**kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*,<br>infer_missing: bool = False,<br>only=None,<br>exclude=(),<br>many: bool = False,<br>context=None,<br>load_only=(),<br>dump_only=(),<br>partial: bool = False,<br>unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileInfo.author"><code class="name">var <span class="ident">author</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.comment"><code class="name">var <span class="ident">comment</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.path"><code class="name">var <span class="ident">path</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileInfo.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, dict | list | str | int | float | bool | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileInfo.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self,<br>*,<br>skipkeys: bool = False,<br>ensure_ascii: bool = True,<br>check_circular: bool = True,<br>allow_nan: bool = True,<br>indent: int | str | None = None,<br>separators: Tuple[str, str] | None = None,<br>default: Callable | None = None,<br>sort_keys: bool = False,<br>**kw) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Optional[Tuple[str, str]] = None,
            default: Optional[Callable] = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision"><code class="flex name class">
<span>class <span class="ident">ConfigFileRevision</span></span>
<span>(</span><span>id: str, author: str, comment: str, time: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigFileRevision:
    &#34;&#34;&#34;
    Holds information about a specific version of a config file
    &#34;&#34;&#34;
    id: str
    author: str
    comment: str
    time: str</code></pre>
</details>
<div class="desc"><p>Holds information about a specific version of a config file</p></div>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileRevision.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: dict | list | str | int | float | bool | None, *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: str | bytes | bytearray,<br>*,<br>parse_float=None,<br>parse_int=None,<br>parse_constant=None,<br>infer_missing=False,<br>**kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*,<br>infer_missing: bool = False,<br>only=None,<br>exclude=(),<br>many: bool = False,<br>context=None,<br>load_only=(),<br>dump_only=(),<br>partial: bool = False,<br>unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileRevision.author"><code class="name">var <span class="ident">author</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.comment"><code class="name">var <span class="ident">comment</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.time"><code class="name">var <span class="ident">time</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigFileRevision.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, dict | list | str | int | float | bool | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigFileRevision.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self,<br>*,<br>skipkeys: bool = False,<br>ensure_ascii: bool = True,<br>check_circular: bool = True,<br>allow_nan: bool = True,<br>indent: int | str | None = None,<br>separators: Tuple[str, str] | None = None,<br>default: Callable | None = None,<br>sort_keys: bool = False,<br>**kw) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Optional[Tuple[str, str]] = None,
            default: Optional[Callable] = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigId"><code class="flex name class">
<span>class <span class="ident">ConfigId</span></span>
<span>(</span><span>id: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigId:
    &#34;&#34;&#34;
    Type of an id returned from ConfigManager create or update methods
    &#34;&#34;&#34;
    id: str</code></pre>
</details>
<div class="desc"><p>Type of an id returned from ConfigManager create or update methods</p></div>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigId.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: dict | list | str | int | float | bool | None, *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigId.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: str | bytes | bytearray,<br>*,<br>parse_float=None,<br>parse_int=None,<br>parse_constant=None,<br>infer_missing=False,<br>**kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigId.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*,<br>infer_missing: bool = False,<br>only=None,<br>exclude=(),<br>many: bool = False,<br>context=None,<br>load_only=(),<br>dump_only=(),<br>partial: bool = False,<br>unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigId.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigId.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, dict | list | str | int | float | bool | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigId.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self,<br>*,<br>skipkeys: bool = False,<br>ensure_ascii: bool = True,<br>check_circular: bool = True,<br>allow_nan: bool = True,<br>indent: int | str | None = None,<br>separators: Tuple[str, str] | None = None,<br>default: Callable | None = None,<br>sort_keys: bool = False,<br>**kw) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Optional[Tuple[str, str]] = None,
            default: Optional[Callable] = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigMetadata"><code class="flex name class">
<span>class <span class="ident">ConfigMetadata</span></span>
<span>(</span><span>repoPath: str, annexPath: str, annexMinFileSize: str, maxConfigFileSize: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class ConfigMetadata:
    &#34;&#34;&#34;
    Holds metadata information about config server
    &#34;&#34;&#34;
    repoPath: str
    annexPath: str
    annexMinFileSize: str
    maxConfigFileSize: str</code></pre>
</details>
<div class="desc"><p>Holds metadata information about config server</p></div>
<h3>Static methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigMetadata.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: dict | list | str | int | float | bool | None, *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: str | bytes | bytearray,<br>*,<br>parse_float=None,<br>parse_int=None,<br>parse_constant=None,<br>infer_missing=False,<br>**kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*,<br>infer_missing: bool = False,<br>only=None,<br>exclude=(),<br>many: bool = False,<br>context=None,<br>load_only=(),<br>dump_only=(),<br>partial: bool = False,<br>unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="csw.ConfigService.ConfigMetadata.annexMinFileSize"><code class="name">var <span class="ident">annexMinFileSize</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.annexPath"><code class="name">var <span class="ident">annexPath</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.maxConfigFileSize"><code class="name">var <span class="ident">maxConfigFileSize</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.repoPath"><code class="name">var <span class="ident">repoPath</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigMetadata.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, dict | list | str | int | float | bool | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="csw.ConfigService.ConfigMetadata.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self,<br>*,<br>skipkeys: bool = False,<br>ensure_ascii: bool = True,<br>check_circular: bool = True,<br>allow_nan: bool = True,<br>indent: int | str | None = None,<br>separators: Tuple[str, str] | None = None,<br>default: Callable | None = None,<br>sort_keys: bool = False,<br>**kw) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Optional[Tuple[str, str]] = None,
            default: Optional[Callable] = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.ConfigService"><code class="flex name class">
<span>class <span class="ident">ConfigService</span></span>
<span>(</span><span>clientSession: aiohttp.client.ClientSession,<br>client_id: str = 'tmt-frontend-app',<br>user: str = 'config-admin1',<br>password: str = 'config-admin1')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigService:

    def __init__(self,
                 clientSession: ClientSession,
                 client_id: str = &#34;tmt-frontend-app&#34;,
                 user: str = &#34;config-admin1&#34;,
                 password: str = &#34;config-admin1&#34;,):
        self._session = clientSession
        self.client_id = client_id
        self.user = user
        self.password = password
        self._locationService = LocationService(clientSession)

    @staticmethod
    def _formatTime(time: datetime):
        return time.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

    async def _getBaseUri(self) -&gt; str:
        prefix = Prefix(Subsystem.CSW, &#34;ConfigServer&#34;)
        connection = ConnectionInfo.make(prefix, ComponentType.Service, ConnectionType.HttpType)
        location = await self._locationService.resolve(connection)
        if location is not None:
            location.__class__ = HttpLocation
            return location.uri
        raise RuntimeError(&#34;Can&#39;t locate CSW Config Service&#34;)

    async def _endPoint(self, path: str) -&gt; str:
        return f&#39;{await self._getBaseUri()}{path}&#39;

    async def _locateAuthService(self) -&gt; str:
        connection = ConnectionInfo.make(Prefix(Subsystem.CSW, &#34;AAS&#34;), ComponentType.Service, ConnectionType.HttpType)
        location = await self._locationService.resolve(connection)
        if location is not None:
            location.__class__ = HttpLocation
            return location.uri
        raise RuntimeError(&#34;Can&#39;t locate CSW Auth Service&#34;)

    async def _getToken(self):
        uri = await self._locateAuthService()
        keycloak_openid = KeycloakOpenID(server_url=f&#39;{uri}/&#39;,
                                         client_id=self.client_id,
                                         realm_name=&#39;TMT&#39;)
        d = keycloak_openid.token(self.user, self.password)
        return d[&#39;access_token&#39;]

    @staticmethod
    def _validatePath(path: str):
        invalidChars = &#34;!#&lt;&gt;$%&amp;&#39;@^`~+,;=\\s&#34;
        if re.match(invalidChars, path):
            charsMessage = invalidChars.replace(&#39;\\s&#39;, &#39;&#39;)
            raise RuntimeError(
                f&#34;Input file path &#39;{path}&#39; contains invalid characters. &#34;
                + f&#34;Note, these characters {charsMessage} or &#39;white space&#39; are not allowed in file path`&#34;)

    async def _createOrUpdate(self, create: bool, path: str, configData: ConfigData,
                        annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        self._validatePath(path)
        token = await self._getToken()
        params = urlencode({&#39;annex&#39;: annex, &#39;comment&#39;: comment})
        baseUri = await self._endPoint(f&#39;config/{path}&#39;)
        uri = f&#39;{baseUri}?{params}&#39;
        headers = {&#39;Content-type&#39;: &#39;application/octet-stream&#39;, &#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        if create:
            response = await self._session.post(uri, headers=headers, data=configData.content)
        else:
            response = await self._session.put(uri, headers=headers, data=configData.content)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigId(await response.json())

    async def create(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        &#34;&#34;&#34;
        Creates a file at a specified path with given data and comment.

        Args:
            path (str): the file path relative to the repository root
            configData (ConfigData): contents of the file
            annex (bool): true if the file is annex and requires special handling (external storage)
            comment (str): comment to associate with this operation

        Returns: id of file revision
        &#34;&#34;&#34;
        return await self._createOrUpdate(True, path, configData, annex, comment)

    async def update(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
        &#34;&#34;&#34;
        Updates a file at a specified path with given data and comment.

        Args:
            path (str): the file path relative to the repository root
            configData (ConfigData): contents of the file
            annex (bool): true if the file is annex and requires special handling (external storage)
            comment (str): comment to associate with this operation

        Returns: id of file revision
        &#34;&#34;&#34;
        return await self._createOrUpdate(False, path, configData, annex, comment)

    async def delete(self, path: str, comment: str = &#34;Deleted&#34;):
        &#34;&#34;&#34;
        Deletes the given config file (older versions will still be available).

        Args:
            path: the file path relative to the repository root
            comment: comment to associate with this operation
        &#34;&#34;&#34;
        token = await self._getToken()
        params = urlencode({&#39;comment&#39;: comment})
        baseUri = await self._endPoint(f&#39;config/{path}&#39;)
        uri = f&#39;{baseUri}?{params}&#39;
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        response = await self._session.delete(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(await response.text())

    # noinspection PyUnresolvedReferences
    async def list(self, fileType: FileType = None, pattern: str = None) -&gt; List[ConfigFileInfo]:
        &#34;&#34;&#34;
        Returns a list containing all the known config files of given type(Annex or Normal) and whose name matches the provided pattern.

        Args:
            fileType: optional file type(Annex or Normal)
            pattern: optional pattern to match against the file name

        Returns: list of ConfigFileInfo

        &#34;&#34;&#34;
        params = {}
        if fileType:
            params.update({&#39;type&#39;: fileType.name})
        if pattern:
            params.update({&#39;pattern&#39;: pattern})
        uri = f&#34;{await self._endPoint(&#39;list&#39;)}?{urlencode(params)}&#34;
        response = await self._session.get(uri)
        return list(map(lambda p: ConfigFileInfo.from_dict(p), await response.json()))

    async def exists(self, path: str, configId: ConfigId = None):
        &#34;&#34;&#34;
        Returns true if the given path exists and is being managed.

        Args:
            path: the file path relative to the repository root
            configId: revision of the file

        Returns: true if the file exists in the repo
        &#34;&#34;&#34;
        params = {}
        if configId:
            params.update({&#39;id&#39;: configId.id})
        uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = await self._session.head(uri)
        return response.ok

    async def getLatest(self, path: str) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the content of latest version of the file stored under the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: file contents
        &#34;&#34;&#34;
        uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigData(await response.content.read())

    async def getById(self, path: str, configId: ConfigId) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the file at the given path with the specified revision id

        Args:
            path (str): the file path relative to the repository root
            configId (ConfigId):  id used to specify a specific version to fetch

        Returns: file contents
        &#34;&#34;&#34;
        params = {&#39;id&#39;: configId.id}
        uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigData(await response.content.read())

    async def getByTime(self, path: str, time: datetime) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets the file at the given path as it existed on the given instant.
        If instant is before the file was created, the initial version is returned.
        If instant is after the last change, the most recent version is returned.

        Args:
            path (str): the file path relative to the repository root
            time (datetime): the target instant

        Returns: file contents
        &#34;&#34;&#34;
        params = {&#39;date&#39;: self._formatTime(time)}
        uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigData(await response.content.read())

    async def getActive(self, path: str) -&gt; ConfigData:
        &#34;&#34;&#34;
        Gets and returns the content of active version of the file stored under the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: file contents

        &#34;&#34;&#34;
        uri = f&#34;{await self._endPoint(&#39;active-config&#39;)}/{path}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigData(await response.content.read())

    async def getActiveByTime(self, path: str, time: datetime) -&gt; ConfigData:
        &#34;&#34;&#34;
        Returns the content of active version of the file at the given path as it existed on the given instant

        Args:
            path (str): the file path relative to the repository root
            time (datetime): the target instant

        Returns: file contents

        &#34;&#34;&#34;
        params = {&#39;date&#39;: self._formatTime(time)}
        uri = f&#34;{await self._endPoint(&#39;active-config&#39;)}/{path}?{urlencode(params)}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigData(await response.content.read())

    async def getActiveVersion(self, path: str) -&gt; ConfigId:
        &#34;&#34;&#34;
        Returns the version which represents the &#34;active version&#34; of the file at the given path.

        Args:
            path (str): the file path relative to the repository root

        Returns: ConfigId indicating the id of the active version

        &#34;&#34;&#34;
        uri = f&#34;{await self._endPoint(&#39;active-version&#39;)}/{path}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigId(await response.json())

    # noinspection PyUnresolvedReferences
    async def getMetadata(self) -&gt; ConfigMetadata:
        &#34;&#34;&#34;
        Query the metadata of config server.
        Returns: a ConfigMetadata object

        &#34;&#34;&#34;
        uri = f&#34;{await self._endPoint(&#39;metadata&#39;)}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return ConfigMetadata.from_dict(await response.json())

    # noinspection PyUnresolvedReferences
    async def _history(self, key: str, path: str,
                 fromTime: datetime, toTime: datetime,
                 maxResults: int) -&gt; List[ConfigFileRevision]:
        params = {}
        if fromTime:
            params.update({&#39;from&#39;: self._formatTime(fromTime)})
        if toTime:
            params.update({&#39;to&#39;: self._formatTime(toTime)})
        if maxResults:
            params.update({&#39;maxResults&#39;: maxResults})
        uri = f&#34;{await self._endPoint(key)}/{path}?{urlencode(params)}&#34;
        response = await self._session.get(uri)
        if not response.ok:
            raise RuntimeError(await response.text())
        return list(map(lambda p: ConfigFileRevision.from_dict(p), await response.json()))

    async def history(self, path: str,
                fromTime: datetime = None, toTime: datetime = None,
                maxResults: int = 10000) -&gt; List[ConfigFileRevision]:
        &#34;&#34;&#34;
        Returns the history of versions of the file at the given path for a range of period specified by from and to.
        The size of the list is limited upto maxResults.

        Args:
            path: the file path relative to the repository root
            fromTime: optional start of the history range
            toTime: optional end of the history range
            maxResults: optional maximum number of history results to return (default: unlimited)

        Returns: list of ConfigFileRevision

        &#34;&#34;&#34;
        return await self._history(&#39;history&#39;, path, fromTime, toTime, maxResults)

    async def historyActive(self, path: str,
                      fromTime: datetime = None, toTime: datetime = None,
                      maxResults: int = None) -&gt; List[ConfigFileRevision]:
        &#34;&#34;&#34;
        Returns the history of active versions of the file at the given path for a range of period specified by
        fromTime and toTime. The size of the list is limited upto maxResults.

        Args:
            path: the file path relative to the repository root
            fromTime: optional start of the history range
            toTime: optional end of the history range
            maxResults: optional maximum number of history results to return (default: unlimited)

        Returns: list of ConfigFileRevision

        &#34;&#34;&#34;
        return await self._history(&#39;history-active&#39;, path, fromTime, toTime, maxResults)

    async def setActiveVersion(self, path: str, configId: ConfigId, comment: str):
        &#34;&#34;&#34;
        Sets the active version to be the version provided for the file at the given path.
        If this method is not called, the active version will always be the version with which the file was created.
        After calling this method, the version with the given Id will be the active version.

        Args:
            path: the file path relative to the repository root
            configId: an id used to specify a specific version (by default the id of the version with which
                      the file was created i.e. 1)
            comment: comment to associate with this operation

        &#34;&#34;&#34;
        token = await self._getToken()
        params = {&#39;id&#39;: configId.id, &#39;comment&#39;: comment}
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        uri = f&#34;{await self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
        response = await self._session.put(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(await response.text())

    async def resetActiveVersion(self, path: str, comment: str):
        &#34;&#34;&#34;
        Resets the &#34;active version&#34; of the file at the given path to the latest version.

        Args:
            path: the file path relative to the repository root
            comment: comment to associate with this operation

        &#34;&#34;&#34;
        token = await self._getToken()
        params = {&#39;comment&#39;: comment}
        headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
        uri = f&#34;{await self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
        response = await self._session.put(uri, headers=headers)
        if not response.ok:
            raise RuntimeError(await response.text())</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="csw.ConfigService.ConfigService.create"><code class="name flex">
<span>async def <span class="ident">create</span></span>(<span>self,<br>path: str,<br>configData: <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a>,<br>annex: bool = False,<br>comment: str = 'Created') ‑> <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
    &#34;&#34;&#34;
    Creates a file at a specified path with given data and comment.

    Args:
        path (str): the file path relative to the repository root
        configData (ConfigData): contents of the file
        annex (bool): true if the file is annex and requires special handling (external storage)
        comment (str): comment to associate with this operation

    Returns: id of file revision
    &#34;&#34;&#34;
    return await self._createOrUpdate(True, path, configData, annex, comment)</code></pre>
</details>
<div class="desc"><p>Creates a file at a specified path with given data and comment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configData</code></strong> :&ensp;<code><a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></code></dt>
<dd>contents of the file</dd>
<dt><strong><code>annex</code></strong> :&ensp;<code>bool</code></dt>
<dd>true if the file is annex and requires special handling (external storage)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>comment to associate with this operation</dd>
</dl>
<p>Returns: id of file revision</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.delete"><code class="name flex">
<span>async def <span class="ident">delete</span></span>(<span>self, path: str, comment: str = 'Deleted')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete(self, path: str, comment: str = &#34;Deleted&#34;):
    &#34;&#34;&#34;
    Deletes the given config file (older versions will still be available).

    Args:
        path: the file path relative to the repository root
        comment: comment to associate with this operation
    &#34;&#34;&#34;
    token = await self._getToken()
    params = urlencode({&#39;comment&#39;: comment})
    baseUri = await self._endPoint(f&#39;config/{path}&#39;)
    uri = f&#39;{baseUri}?{params}&#39;
    headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
    response = await self._session.delete(uri, headers=headers)
    if not response.ok:
        raise RuntimeError(await response.text())</code></pre>
</details>
<div class="desc"><p>Deletes the given config file (older versions will still be available).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>comment to associate with this operation</dd>
</dl></div>
</dd>
<dt id="csw.ConfigService.ConfigService.exists"><code class="name flex">
<span>async def <span class="ident">exists</span></span>(<span>self,<br>path: str,<br>configId: <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a> = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def exists(self, path: str, configId: ConfigId = None):
    &#34;&#34;&#34;
    Returns true if the given path exists and is being managed.

    Args:
        path: the file path relative to the repository root
        configId: revision of the file

    Returns: true if the file exists in the repo
    &#34;&#34;&#34;
    params = {}
    if configId:
        params.update({&#39;id&#39;: configId.id})
    uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
    response = await self._session.head(uri)
    return response.ok</code></pre>
</details>
<div class="desc"><p>Returns true if the given path exists and is being managed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configId</code></strong></dt>
<dd>revision of the file</dd>
</dl>
<p>Returns: true if the file exists in the repo</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.getActive"><code class="name flex">
<span>async def <span class="ident">getActive</span></span>(<span>self, path: str) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getActive(self, path: str) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets and returns the content of active version of the file stored under the given path.

    Args:
        path (str): the file path relative to the repository root

    Returns: file contents

    &#34;&#34;&#34;
    uri = f&#34;{await self._endPoint(&#39;active-config&#39;)}/{path}&#34;
    response = await self._session.get(uri)
    if not response.ok:
        raise RuntimeError(await response.text())
    return ConfigData(await response.content.read())</code></pre>
</details>
<div class="desc"><p>Gets and returns the content of active version of the file stored under the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
</dl>
<p>Returns: file contents</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.getActiveByTime"><code class="name flex">
<span>async def <span class="ident">getActiveByTime</span></span>(<span>self, path: str, time: datetime.datetime) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getActiveByTime(self, path: str, time: datetime) -&gt; ConfigData:
    &#34;&#34;&#34;
    Returns the content of active version of the file at the given path as it existed on the given instant

    Args:
        path (str): the file path relative to the repository root
        time (datetime): the target instant

    Returns: file contents

    &#34;&#34;&#34;
    params = {&#39;date&#39;: self._formatTime(time)}
    uri = f&#34;{await self._endPoint(&#39;active-config&#39;)}/{path}?{urlencode(params)}&#34;
    response = await self._session.get(uri)
    if not response.ok:
        raise RuntimeError(await response.text())
    return ConfigData(await response.content.read())</code></pre>
</details>
<div class="desc"><p>Returns the content of active version of the file at the given path as it existed on the given instant</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>the target instant</dd>
</dl>
<p>Returns: file contents</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.getActiveVersion"><code class="name flex">
<span>async def <span class="ident">getActiveVersion</span></span>(<span>self, path: str) ‑> <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getActiveVersion(self, path: str) -&gt; ConfigId:
    &#34;&#34;&#34;
    Returns the version which represents the &#34;active version&#34; of the file at the given path.

    Args:
        path (str): the file path relative to the repository root

    Returns: ConfigId indicating the id of the active version

    &#34;&#34;&#34;
    uri = f&#34;{await self._endPoint(&#39;active-version&#39;)}/{path}&#34;
    response = await self._session.get(uri)
    if not response.ok:
        raise RuntimeError(await response.text())
    return ConfigId(await response.json())</code></pre>
</details>
<div class="desc"><p>Returns the version which represents the "active version" of the file at the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
</dl>
<p>Returns: ConfigId indicating the id of the active version</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.getById"><code class="name flex">
<span>async def <span class="ident">getById</span></span>(<span>self,<br>path: str,<br>configId: <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a>) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getById(self, path: str, configId: ConfigId) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets and returns the file at the given path with the specified revision id

    Args:
        path (str): the file path relative to the repository root
        configId (ConfigId):  id used to specify a specific version to fetch

    Returns: file contents
    &#34;&#34;&#34;
    params = {&#39;id&#39;: configId.id}
    uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
    response = await self._session.get(uri)
    if not response.ok:
        raise RuntimeError(await response.text())
    return ConfigData(await response.content.read())</code></pre>
</details>
<div class="desc"><p>Gets and returns the file at the given path with the specified revision id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configId</code></strong> :&ensp;<code><a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></code></dt>
<dd>id used to specify a specific version to fetch</dd>
</dl>
<p>Returns: file contents</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.getByTime"><code class="name flex">
<span>async def <span class="ident">getByTime</span></span>(<span>self, path: str, time: datetime.datetime) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getByTime(self, path: str, time: datetime) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets the file at the given path as it existed on the given instant.
    If instant is before the file was created, the initial version is returned.
    If instant is after the last change, the most recent version is returned.

    Args:
        path (str): the file path relative to the repository root
        time (datetime): the target instant

    Returns: file contents
    &#34;&#34;&#34;
    params = {&#39;date&#39;: self._formatTime(time)}
    uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}?{urlencode(params)}&#34;
    response = await self._session.get(uri)
    if not response.ok:
        raise RuntimeError(await response.text())
    return ConfigData(await response.content.read())</code></pre>
</details>
<div class="desc"><p>Gets the file at the given path as it existed on the given instant.
If instant is before the file was created, the initial version is returned.
If instant is after the last change, the most recent version is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>the target instant</dd>
</dl>
<p>Returns: file contents</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.getLatest"><code class="name flex">
<span>async def <span class="ident">getLatest</span></span>(<span>self, path: str) ‑> <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getLatest(self, path: str) -&gt; ConfigData:
    &#34;&#34;&#34;
    Gets and returns the content of latest version of the file stored under the given path.

    Args:
        path (str): the file path relative to the repository root

    Returns: file contents
    &#34;&#34;&#34;
    uri = f&#34;{await self._endPoint(&#39;config&#39;)}/{path}&#34;
    response = await self._session.get(uri)
    if not response.ok:
        raise RuntimeError(await response.text())
    return ConfigData(await response.content.read())</code></pre>
</details>
<div class="desc"><p>Gets and returns the content of latest version of the file stored under the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
</dl>
<p>Returns: file contents</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.getMetadata"><code class="name flex">
<span>async def <span class="ident">getMetadata</span></span>(<span>self) ‑> <a title="csw.ConfigService.ConfigMetadata" href="#csw.ConfigService.ConfigMetadata">ConfigMetadata</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def getMetadata(self) -&gt; ConfigMetadata:
    &#34;&#34;&#34;
    Query the metadata of config server.
    Returns: a ConfigMetadata object

    &#34;&#34;&#34;
    uri = f&#34;{await self._endPoint(&#39;metadata&#39;)}&#34;
    response = await self._session.get(uri)
    if not response.ok:
        raise RuntimeError(await response.text())
    return ConfigMetadata.from_dict(await response.json())</code></pre>
</details>
<div class="desc"><p>Query the metadata of config server.
Returns: a ConfigMetadata object</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.history"><code class="name flex">
<span>async def <span class="ident">history</span></span>(<span>self,<br>path: str,<br>fromTime: datetime.datetime = None,<br>toTime: datetime.datetime = None,<br>maxResults: int = 10000) ‑> List[<a title="csw.ConfigService.ConfigFileRevision" href="#csw.ConfigService.ConfigFileRevision">ConfigFileRevision</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def history(self, path: str,
            fromTime: datetime = None, toTime: datetime = None,
            maxResults: int = 10000) -&gt; List[ConfigFileRevision]:
    &#34;&#34;&#34;
    Returns the history of versions of the file at the given path for a range of period specified by from and to.
    The size of the list is limited upto maxResults.

    Args:
        path: the file path relative to the repository root
        fromTime: optional start of the history range
        toTime: optional end of the history range
        maxResults: optional maximum number of history results to return (default: unlimited)

    Returns: list of ConfigFileRevision

    &#34;&#34;&#34;
    return await self._history(&#39;history&#39;, path, fromTime, toTime, maxResults)</code></pre>
</details>
<div class="desc"><p>Returns the history of versions of the file at the given path for a range of period specified by from and to.
The size of the list is limited upto maxResults.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>fromTime</code></strong></dt>
<dd>optional start of the history range</dd>
<dt><strong><code>toTime</code></strong></dt>
<dd>optional end of the history range</dd>
<dt><strong><code>maxResults</code></strong></dt>
<dd>optional maximum number of history results to return (default: unlimited)</dd>
</dl>
<p>Returns: list of ConfigFileRevision</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.historyActive"><code class="name flex">
<span>async def <span class="ident">historyActive</span></span>(<span>self,<br>path: str,<br>fromTime: datetime.datetime = None,<br>toTime: datetime.datetime = None,<br>maxResults: int = None) ‑> List[<a title="csw.ConfigService.ConfigFileRevision" href="#csw.ConfigService.ConfigFileRevision">ConfigFileRevision</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def historyActive(self, path: str,
                  fromTime: datetime = None, toTime: datetime = None,
                  maxResults: int = None) -&gt; List[ConfigFileRevision]:
    &#34;&#34;&#34;
    Returns the history of active versions of the file at the given path for a range of period specified by
    fromTime and toTime. The size of the list is limited upto maxResults.

    Args:
        path: the file path relative to the repository root
        fromTime: optional start of the history range
        toTime: optional end of the history range
        maxResults: optional maximum number of history results to return (default: unlimited)

    Returns: list of ConfigFileRevision

    &#34;&#34;&#34;
    return await self._history(&#39;history-active&#39;, path, fromTime, toTime, maxResults)</code></pre>
</details>
<div class="desc"><p>Returns the history of active versions of the file at the given path for a range of period specified by
fromTime and toTime. The size of the list is limited upto maxResults.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>fromTime</code></strong></dt>
<dd>optional start of the history range</dd>
<dt><strong><code>toTime</code></strong></dt>
<dd>optional end of the history range</dd>
<dt><strong><code>maxResults</code></strong></dt>
<dd>optional maximum number of history results to return (default: unlimited)</dd>
</dl>
<p>Returns: list of ConfigFileRevision</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.list"><code class="name flex">
<span>async def <span class="ident">list</span></span>(<span>self,<br>fileType: <a title="csw.ConfigService.FileType" href="#csw.ConfigService.FileType">FileType</a> = None,<br>pattern: str = None) ‑> List[<a title="csw.ConfigService.ConfigFileInfo" href="#csw.ConfigService.ConfigFileInfo">ConfigFileInfo</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def list(self, fileType: FileType = None, pattern: str = None) -&gt; List[ConfigFileInfo]:
    &#34;&#34;&#34;
    Returns a list containing all the known config files of given type(Annex or Normal) and whose name matches the provided pattern.

    Args:
        fileType: optional file type(Annex or Normal)
        pattern: optional pattern to match against the file name

    Returns: list of ConfigFileInfo

    &#34;&#34;&#34;
    params = {}
    if fileType:
        params.update({&#39;type&#39;: fileType.name})
    if pattern:
        params.update({&#39;pattern&#39;: pattern})
    uri = f&#34;{await self._endPoint(&#39;list&#39;)}?{urlencode(params)}&#34;
    response = await self._session.get(uri)
    return list(map(lambda p: ConfigFileInfo.from_dict(p), await response.json()))</code></pre>
</details>
<div class="desc"><p>Returns a list containing all the known config files of given type(Annex or Normal) and whose name matches the provided pattern.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fileType</code></strong></dt>
<dd>optional file type(Annex or Normal)</dd>
<dt><strong><code>pattern</code></strong></dt>
<dd>optional pattern to match against the file name</dd>
</dl>
<p>Returns: list of ConfigFileInfo</p></div>
</dd>
<dt id="csw.ConfigService.ConfigService.resetActiveVersion"><code class="name flex">
<span>async def <span class="ident">resetActiveVersion</span></span>(<span>self, path: str, comment: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def resetActiveVersion(self, path: str, comment: str):
    &#34;&#34;&#34;
    Resets the &#34;active version&#34; of the file at the given path to the latest version.

    Args:
        path: the file path relative to the repository root
        comment: comment to associate with this operation

    &#34;&#34;&#34;
    token = await self._getToken()
    params = {&#39;comment&#39;: comment}
    headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
    uri = f&#34;{await self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
    response = await self._session.put(uri, headers=headers)
    if not response.ok:
        raise RuntimeError(await response.text())</code></pre>
</details>
<div class="desc"><p>Resets the "active version" of the file at the given path to the latest version.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>comment to associate with this operation</dd>
</dl></div>
</dd>
<dt id="csw.ConfigService.ConfigService.setActiveVersion"><code class="name flex">
<span>async def <span class="ident">setActiveVersion</span></span>(<span>self,<br>path: str,<br>configId: <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a>,<br>comment: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def setActiveVersion(self, path: str, configId: ConfigId, comment: str):
    &#34;&#34;&#34;
    Sets the active version to be the version provided for the file at the given path.
    If this method is not called, the active version will always be the version with which the file was created.
    After calling this method, the version with the given Id will be the active version.

    Args:
        path: the file path relative to the repository root
        configId: an id used to specify a specific version (by default the id of the version with which
                  the file was created i.e. 1)
        comment: comment to associate with this operation

    &#34;&#34;&#34;
    token = await self._getToken()
    params = {&#39;id&#39;: configId.id, &#39;comment&#39;: comment}
    headers = {&#39;Authorization&#39;: f&#39;Bearer {token}&#39;}
    uri = f&#34;{await self._endPoint(&#39;active-version&#39;)}/{path}?{urlencode(params)}&#34;
    response = await self._session.put(uri, headers=headers)
    if not response.ok:
        raise RuntimeError(await response.text())</code></pre>
</details>
<div class="desc"><p>Sets the active version to be the version provided for the file at the given path.
If this method is not called, the active version will always be the version with which the file was created.
After calling this method, the version with the given Id will be the active version.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configId</code></strong></dt>
<dd>an id used to specify a specific version (by default the id of the version with which
the file was created i.e. 1)</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>comment to associate with this operation</dd>
</dl></div>
</dd>
<dt id="csw.ConfigService.ConfigService.update"><code class="name flex">
<span>async def <span class="ident">update</span></span>(<span>self,<br>path: str,<br>configData: <a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a>,<br>annex: bool = False,<br>comment: str = 'Created') ‑> <a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update(self, path: str, configData: ConfigData, annex: bool = False, comment: str = &#34;Created&#34;) -&gt; ConfigId:
    &#34;&#34;&#34;
    Updates a file at a specified path with given data and comment.

    Args:
        path (str): the file path relative to the repository root
        configData (ConfigData): contents of the file
        annex (bool): true if the file is annex and requires special handling (external storage)
        comment (str): comment to associate with this operation

    Returns: id of file revision
    &#34;&#34;&#34;
    return await self._createOrUpdate(False, path, configData, annex, comment)</code></pre>
</details>
<div class="desc"><p>Updates a file at a specified path with given data and comment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the file path relative to the repository root</dd>
<dt><strong><code>configData</code></strong> :&ensp;<code><a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></code></dt>
<dd>contents of the file</dd>
<dt><strong><code>annex</code></strong> :&ensp;<code>bool</code></dt>
<dd>true if the file is annex and requires special handling (external storage)</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>comment to associate with this operation</dd>
</dl>
<p>Returns: id of file revision</p></div>
</dd>
</dl>
</dd>
<dt id="csw.ConfigService.FileType"><code class="flex name class">
<span>class <span class="ident">FileType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileType(Enum):
    &#34;&#34;&#34;
    Represents the type of storage for a configuration file
    &#34;&#34;&#34;
    Normal = 0
    Annex = 1</code></pre>
</details>
<div class="desc"><p>Represents the type of storage for a configuration file</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="csw.ConfigService.FileType.Annex"><code class="name">var <span class="ident">Annex</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="csw.ConfigService.FileType.Normal"><code class="name">var <span class="ident">Normal</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="csw" href="index.html">csw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="csw.ConfigService.ConfigData" href="#csw.ConfigService.ConfigData">ConfigData</a></code></h4>
<ul class="">
<li><code><a title="csw.ConfigService.ConfigData.content" href="#csw.ConfigService.ConfigData.content">content</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigFileInfo" href="#csw.ConfigService.ConfigFileInfo">ConfigFileInfo</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigFileInfo.author" href="#csw.ConfigService.ConfigFileInfo.author">author</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.comment" href="#csw.ConfigService.ConfigFileInfo.comment">comment</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.from_dict" href="#csw.ConfigService.ConfigFileInfo.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.from_json" href="#csw.ConfigService.ConfigFileInfo.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.id" href="#csw.ConfigService.ConfigFileInfo.id">id</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.path" href="#csw.ConfigService.ConfigFileInfo.path">path</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.schema" href="#csw.ConfigService.ConfigFileInfo.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.to_dict" href="#csw.ConfigService.ConfigFileInfo.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileInfo.to_json" href="#csw.ConfigService.ConfigFileInfo.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigFileRevision" href="#csw.ConfigService.ConfigFileRevision">ConfigFileRevision</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigFileRevision.author" href="#csw.ConfigService.ConfigFileRevision.author">author</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.comment" href="#csw.ConfigService.ConfigFileRevision.comment">comment</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.from_dict" href="#csw.ConfigService.ConfigFileRevision.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.from_json" href="#csw.ConfigService.ConfigFileRevision.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.id" href="#csw.ConfigService.ConfigFileRevision.id">id</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.schema" href="#csw.ConfigService.ConfigFileRevision.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.time" href="#csw.ConfigService.ConfigFileRevision.time">time</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.to_dict" href="#csw.ConfigService.ConfigFileRevision.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigFileRevision.to_json" href="#csw.ConfigService.ConfigFileRevision.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigId" href="#csw.ConfigService.ConfigId">ConfigId</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigId.from_dict" href="#csw.ConfigService.ConfigId.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.from_json" href="#csw.ConfigService.ConfigId.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.id" href="#csw.ConfigService.ConfigId.id">id</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.schema" href="#csw.ConfigService.ConfigId.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.to_dict" href="#csw.ConfigService.ConfigId.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigId.to_json" href="#csw.ConfigService.ConfigId.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigMetadata" href="#csw.ConfigService.ConfigMetadata">ConfigMetadata</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigMetadata.annexMinFileSize" href="#csw.ConfigService.ConfigMetadata.annexMinFileSize">annexMinFileSize</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.annexPath" href="#csw.ConfigService.ConfigMetadata.annexPath">annexPath</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.from_dict" href="#csw.ConfigService.ConfigMetadata.from_dict">from_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.from_json" href="#csw.ConfigService.ConfigMetadata.from_json">from_json</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.maxConfigFileSize" href="#csw.ConfigService.ConfigMetadata.maxConfigFileSize">maxConfigFileSize</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.repoPath" href="#csw.ConfigService.ConfigMetadata.repoPath">repoPath</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.schema" href="#csw.ConfigService.ConfigMetadata.schema">schema</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.to_dict" href="#csw.ConfigService.ConfigMetadata.to_dict">to_dict</a></code></li>
<li><code><a title="csw.ConfigService.ConfigMetadata.to_json" href="#csw.ConfigService.ConfigMetadata.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.ConfigService" href="#csw.ConfigService.ConfigService">ConfigService</a></code></h4>
<ul class="two-column">
<li><code><a title="csw.ConfigService.ConfigService.create" href="#csw.ConfigService.ConfigService.create">create</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.delete" href="#csw.ConfigService.ConfigService.delete">delete</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.exists" href="#csw.ConfigService.ConfigService.exists">exists</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getActive" href="#csw.ConfigService.ConfigService.getActive">getActive</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getActiveByTime" href="#csw.ConfigService.ConfigService.getActiveByTime">getActiveByTime</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getActiveVersion" href="#csw.ConfigService.ConfigService.getActiveVersion">getActiveVersion</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getById" href="#csw.ConfigService.ConfigService.getById">getById</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getByTime" href="#csw.ConfigService.ConfigService.getByTime">getByTime</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getLatest" href="#csw.ConfigService.ConfigService.getLatest">getLatest</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.getMetadata" href="#csw.ConfigService.ConfigService.getMetadata">getMetadata</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.history" href="#csw.ConfigService.ConfigService.history">history</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.historyActive" href="#csw.ConfigService.ConfigService.historyActive">historyActive</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.list" href="#csw.ConfigService.ConfigService.list">list</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.resetActiveVersion" href="#csw.ConfigService.ConfigService.resetActiveVersion">resetActiveVersion</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.setActiveVersion" href="#csw.ConfigService.ConfigService.setActiveVersion">setActiveVersion</a></code></li>
<li><code><a title="csw.ConfigService.ConfigService.update" href="#csw.ConfigService.ConfigService.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.ConfigService.FileType" href="#csw.ConfigService.FileType">FileType</a></code></h4>
<ul class="">
<li><code><a title="csw.ConfigService.FileType.Annex" href="#csw.ConfigService.FileType.Annex">Annex</a></code></li>
<li><code><a title="csw.ConfigService.FileType.Normal" href="#csw.ConfigService.FileType.Normal">Normal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
