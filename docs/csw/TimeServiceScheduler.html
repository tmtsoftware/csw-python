<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>csw.TimeServiceScheduler API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>csw.TimeServiceScheduler</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="csw.TimeServiceScheduler.TimeServiceScheduler"><code class="flex name class">
<span>class <span class="ident">TimeServiceScheduler</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeServiceScheduler:
    &#34;&#34;&#34;
    Scheduler for scheduling periodic/non-periodic tasks at a specified time and/or interval.
    It supports scheduling on both UTCTime and TAITime.
    Each API returns a Cancellable which allows users to cancel the execution of tasks.
    Please note that implementation of Scheduler is optimised for high-throughput
    and high-frequency events. It is not to be confused with long-term schedulers such as Quartz.
    &#34;&#34;&#34;

    log = structlog.get_logger()

    def scheduleOnce(self, startTime: TMTTime, func: Callable[[], Awaitable]) -&gt; Cancellable:
        &#34;&#34;&#34;
        Schedules an async function to execute once at the given start time.

        Args:
            startTime: the time at which the task should start its execution
            func: the async function (coroutine) to be scheduled for execution

        Returns:
            a handle to cancel the execution of the task if it hasn&#39;t been executed already
        &#34;&#34;&#34;
        event = asyncio.Event()
        loop = asyncio.get_running_loop()
        secs = startTime.durationFromNow().total_seconds()
        timerHandle = loop.call_later(secs, lambda: event.set())

        async def wrapper():
            await event.wait()
            return await func()

        task = asyncio.create_task(wrapper())
        return TimerCancellable(timerHandle, task)

    def schedulePeriodically(self, interval: timedelta, func: Callable[[], Awaitable]) -&gt; Cancellable:
        &#34;&#34;&#34;
        Schedules a function to execute periodically at the given interval.
        The function is executed once immediately without any initial delay followed by periodic executions.
        In case you do not want to start scheduling immediately, you can use the overloaded method for `schedulePeriodically` with startTime.

        Args:
            interval: the time interval between the executions of the function
            func: the function to execute at each interval

        Returns:
            a handle to cancel execution of further tasks
        &#34;&#34;&#34;
        secs = interval.total_seconds()

        async def periodic():
            while True:
                await func()
                await asyncio.sleep(secs)

        task = asyncio.create_task(periodic())
        return TimerCancellable(None, task)

    def schedulePeriodicallyStarting(self, startTime: TMTTime, interval: timedelta,
                             func: Callable[[], Awaitable]) -&gt; Cancellable:
        &#34;&#34;&#34;
        Schedules a function to execute periodically at the given interval.
        The task is executed once at the given start time followed by execution of task at each interval.

        Args:
            startTime: first time at which task is to be executed
            interval: the time interval between the executions of the function
            func: the function to execute at each interval

        Returns:
            a handle to cancel execution of further tasks
        &#34;&#34;&#34;
        startSecs = startTime.durationFromNow().total_seconds()
        secs = interval.total_seconds()
        event = asyncio.Event()
        loop = asyncio.get_running_loop()

        async def periodic():
            await event.wait()
            while True:
                await func()
                await asyncio.sleep(secs)

        timerHandle = loop.call_later(startSecs, lambda: event.set())
        task = asyncio.create_task(periodic())
        return TimerCancellable(timerHandle, task)</code></pre>
</details>
<div class="desc"><p>Scheduler for scheduling periodic/non-periodic tasks at a specified time and/or interval.
It supports scheduling on both UTCTime and TAITime.
Each API returns a Cancellable which allows users to cancel the execution of tasks.
Please note that implementation of Scheduler is optimised for high-throughput
and high-frequency events. It is not to be confused with long-term schedulers such as Quartz.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="csw.TimeServiceScheduler.TimeServiceScheduler.log"><code class="name">var <span class="ident">log</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csw.TimeServiceScheduler.TimeServiceScheduler.scheduleOnce"><code class="name flex">
<span>def <span class="ident">scheduleOnce</span></span>(<span>self,<br>startTime: <a title="csw.TMTTime.TMTTime" href="TMTTime.html#csw.TMTTime.TMTTime">TMTTime</a>,<br>func: Callable[[], Awaitable]) ‑> <a title="csw.Cancellable.Cancellable" href="Cancellable.html#csw.Cancellable.Cancellable">Cancellable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scheduleOnce(self, startTime: TMTTime, func: Callable[[], Awaitable]) -&gt; Cancellable:
    &#34;&#34;&#34;
    Schedules an async function to execute once at the given start time.

    Args:
        startTime: the time at which the task should start its execution
        func: the async function (coroutine) to be scheduled for execution

    Returns:
        a handle to cancel the execution of the task if it hasn&#39;t been executed already
    &#34;&#34;&#34;
    event = asyncio.Event()
    loop = asyncio.get_running_loop()
    secs = startTime.durationFromNow().total_seconds()
    timerHandle = loop.call_later(secs, lambda: event.set())

    async def wrapper():
        await event.wait()
        return await func()

    task = asyncio.create_task(wrapper())
    return TimerCancellable(timerHandle, task)</code></pre>
</details>
<div class="desc"><p>Schedules an async function to execute once at the given start time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>startTime</code></strong></dt>
<dd>the time at which the task should start its execution</dd>
<dt><strong><code>func</code></strong></dt>
<dd>the async function (coroutine) to be scheduled for execution</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to cancel the execution of the task if it hasn't been executed already</p></div>
</dd>
<dt id="csw.TimeServiceScheduler.TimeServiceScheduler.schedulePeriodically"><code class="name flex">
<span>def <span class="ident">schedulePeriodically</span></span>(<span>self, interval: datetime.timedelta, func: Callable[[], Awaitable]) ‑> <a title="csw.Cancellable.Cancellable" href="Cancellable.html#csw.Cancellable.Cancellable">Cancellable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schedulePeriodically(self, interval: timedelta, func: Callable[[], Awaitable]) -&gt; Cancellable:
    &#34;&#34;&#34;
    Schedules a function to execute periodically at the given interval.
    The function is executed once immediately without any initial delay followed by periodic executions.
    In case you do not want to start scheduling immediately, you can use the overloaded method for `schedulePeriodically` with startTime.

    Args:
        interval: the time interval between the executions of the function
        func: the function to execute at each interval

    Returns:
        a handle to cancel execution of further tasks
    &#34;&#34;&#34;
    secs = interval.total_seconds()

    async def periodic():
        while True:
            await func()
            await asyncio.sleep(secs)

    task = asyncio.create_task(periodic())
    return TimerCancellable(None, task)</code></pre>
</details>
<div class="desc"><p>Schedules a function to execute periodically at the given interval.
The function is executed once immediately without any initial delay followed by periodic executions.
In case you do not want to start scheduling immediately, you can use the overloaded method for <code>schedulePeriodically</code> with startTime.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interval</code></strong></dt>
<dd>the time interval between the executions of the function</dd>
<dt><strong><code>func</code></strong></dt>
<dd>the function to execute at each interval</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to cancel execution of further tasks</p></div>
</dd>
<dt id="csw.TimeServiceScheduler.TimeServiceScheduler.schedulePeriodicallyStarting"><code class="name flex">
<span>def <span class="ident">schedulePeriodicallyStarting</span></span>(<span>self,<br>startTime: <a title="csw.TMTTime.TMTTime" href="TMTTime.html#csw.TMTTime.TMTTime">TMTTime</a>,<br>interval: datetime.timedelta,<br>func: Callable[[], Awaitable]) ‑> <a title="csw.Cancellable.Cancellable" href="Cancellable.html#csw.Cancellable.Cancellable">Cancellable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schedulePeriodicallyStarting(self, startTime: TMTTime, interval: timedelta,
                         func: Callable[[], Awaitable]) -&gt; Cancellable:
    &#34;&#34;&#34;
    Schedules a function to execute periodically at the given interval.
    The task is executed once at the given start time followed by execution of task at each interval.

    Args:
        startTime: first time at which task is to be executed
        interval: the time interval between the executions of the function
        func: the function to execute at each interval

    Returns:
        a handle to cancel execution of further tasks
    &#34;&#34;&#34;
    startSecs = startTime.durationFromNow().total_seconds()
    secs = interval.total_seconds()
    event = asyncio.Event()
    loop = asyncio.get_running_loop()

    async def periodic():
        await event.wait()
        while True:
            await func()
            await asyncio.sleep(secs)

    timerHandle = loop.call_later(startSecs, lambda: event.set())
    task = asyncio.create_task(periodic())
    return TimerCancellable(timerHandle, task)</code></pre>
</details>
<div class="desc"><p>Schedules a function to execute periodically at the given interval.
The task is executed once at the given start time followed by execution of task at each interval.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>startTime</code></strong></dt>
<dd>first time at which task is to be executed</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>the time interval between the executions of the function</dd>
<dt><strong><code>func</code></strong></dt>
<dd>the function to execute at each interval</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to cancel execution of further tasks</p></div>
</dd>
</dl>
</dd>
<dt id="csw.TimeServiceScheduler.TimerCancellable"><code class="flex name class">
<span>class <span class="ident">TimerCancellable</span></span>
<span>(</span><span>timerHandle: asyncio.events.TimerHandle | None, task: _asyncio.Task | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimerCancellable(Cancellable):
    def __init__(self, timerHandle: TimerHandle | None, task: Task | None):
        self.timerHandle = timerHandle
        self.task = task

    def cancel(self) -&gt; bool:
        if self.timerHandle:
            self.timerHandle.cancel()
        if self.task:
            self.task.cancel()
        return True</code></pre>
</details>
<div class="desc"><p>API for a scheduled periodic task, that allows it to be cancelled.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="csw.Cancellable.Cancellable" href="Cancellable.html#csw.Cancellable.Cancellable">Cancellable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="csw.Cancellable.Cancellable" href="Cancellable.html#csw.Cancellable.Cancellable">Cancellable</a></b></code>:
<ul class="hlist">
<li><code><a title="csw.Cancellable.Cancellable.cancel" href="Cancellable.html#csw.Cancellable.Cancellable.cancel">cancel</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="csw" href="index.html">csw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="csw.TimeServiceScheduler.TimeServiceScheduler" href="#csw.TimeServiceScheduler.TimeServiceScheduler">TimeServiceScheduler</a></code></h4>
<ul class="">
<li><code><a title="csw.TimeServiceScheduler.TimeServiceScheduler.log" href="#csw.TimeServiceScheduler.TimeServiceScheduler.log">log</a></code></li>
<li><code><a title="csw.TimeServiceScheduler.TimeServiceScheduler.scheduleOnce" href="#csw.TimeServiceScheduler.TimeServiceScheduler.scheduleOnce">scheduleOnce</a></code></li>
<li><code><a title="csw.TimeServiceScheduler.TimeServiceScheduler.schedulePeriodically" href="#csw.TimeServiceScheduler.TimeServiceScheduler.schedulePeriodically">schedulePeriodically</a></code></li>
<li><code><a title="csw.TimeServiceScheduler.TimeServiceScheduler.schedulePeriodicallyStarting" href="#csw.TimeServiceScheduler.TimeServiceScheduler.schedulePeriodicallyStarting">schedulePeriodicallyStarting</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="csw.TimeServiceScheduler.TimerCancellable" href="#csw.TimeServiceScheduler.TimerCancellable">TimerCancellable</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
